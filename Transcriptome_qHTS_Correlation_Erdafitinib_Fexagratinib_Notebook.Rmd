---
title: "Mim's RNSseq STAR_RSEM ENSEMBL priming and gene expression correlations with drug sensitivities for Erdafitinib/Fexagratinib from qHTS results"
output: html_document
editor_options: 
  chunk_output_type: inline
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.


```{r}
# VST → Drug-specific FGFR panels → Erdafitinib & Fexagratinib analysis ──────
suppressPackageStartupMessages({
  library(DESeq2); library(readr); library(dplyr); library(tidyr)
  library(AnnotationDbi); library(org.Hs.eg.db)
  library(ggplot2); library(ggrepel)
  library(limma)     # removeBatchEffect
  library(purrr)     # map_dfr
  library(cowplot)   # side stamp composition
})

# INPUTS
counts_tsv     <- "left_merged_STS_Batches_1_2_gene_counts.tsv"
sampleinfo_csv <- "sampleinfo_STS_DrugSens_2025.csv"    # name, Batch, cell_type
erda_csv       <- "erdafitinib_metrics.csv"             # cell_line, IC50_nM, AUC (1=death)
fexa_csv       <- "fexagratinib_metrics.csv"            # same columns
out_root       <- file.path(getwd(), "fgfr_drug_specific_results"); dir.create(out_root, FALSE, TRUE)

to_num <- function(x) suppressWarnings(readr::parse_number(as.character(x)))
`%||%` <- function(a,b) if (!is.null(a)) a else b

# Load counts + sample metadata
sampleinfo <- readr::read_csv(sampleinfo_csv, show_col_types = FALSE)
stopifnot(all(c("name","Batch","cell_type") %in% names(sampleinfo)))

rsem_counts <- readr::read_tsv(counts_tsv, show_col_types = FALSE)
gene_ids    <- rsem_counts$gene_id
cnt_mat     <- rsem_counts |> dplyr::select(-1, -2) |> as.data.frame() |> as.matrix()
rownames(cnt_mat) <- gene_ids

stopifnot(all(colnames(cnt_mat) %in% sampleinfo$name))
sampleinfo <- sampleinfo[match(colnames(cnt_mat), sampleinfo$name), , drop = FALSE]
stopifnot(all(colnames(cnt_mat) == sampleinfo$name))

# quick filter: ≥10 counts in ≥4 samples
keep <- rowSums(cnt_mat >= 10) >= 4
cnt_mat <- cnt_mat[keep, , drop = FALSE]

# Map to SYMBOLs and collapse duplicates
sym_map <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = rownames(cnt_mat),
                                 column = "SYMBOL", keytype = "ENSEMBL", multiVals = "first")
cnt_sym <- cnt_mat[!is.na(sym_map), , drop = FALSE]
rownames(cnt_sym) <- sym_map[!is.na(sym_map)]
cnt_sym <- rowsum(cnt_sym, group = rownames(cnt_sym))

# DESeq2 object and VST (blind=FALSE)
sampleinfo$Batch     <- droplevels(factor(sampleinfo$Batch))
sampleinfo$cell_type <- droplevels(factor(sampleinfo$cell_type))

dds <- DESeqDataSetFromMatrix(countData = round(cnt_sym),
                              colData   = sampleinfo,
                              design    = ~ Batch + cell_type)
vsd <- vst(dds, blind = FALSE)
vst_mat <- assay(vsd)

# Remove batch for downstream correlations (viz/metrics only)
vst_bc <- limma::removeBatchEffect(
  vst_mat,
  batch  = colData(vsd)$Batch,
  design = model.matrix(~ cell_type, data = as.data.frame(colData(vsd)))
)

# Collapse replicates → one column per cell line
cell_types <- as.character(colData(vsd)$cell_type)
vst_df <- as.data.frame(vst_bc) |> tibble::rownames_to_column("gene")

vst_avg <- vst_df |>
  tidyr::pivot_longer(-gene, names_to = "sample", values_to = "vst") |>
  dplyr::mutate(cell_line = cell_types[match(sample, colnames(vst_bc))]) |>
  dplyr::group_by(gene, cell_line) |>
  dplyr::summarise(vst = mean(vst, na.rm = TRUE), .groups = "drop") |>
  tidyr::pivot_wider(names_from = cell_line, values_from = vst)

# Save the averaged VST matrix (genes × cell_line)
expr_tsv <- file.path(out_root, "expr_matrix_vst_by_cellline.tsv")
readr::write_tsv(vst_avg, expr_tsv)

# DRUG-SPECIFIC PANELS (edit here for refinement)

# Erdafitinib (guided by DE lists across responder cell lines)
ERDA_pos <- c("FRS2","PLCG1","SHC1","PTPN11","ETV4","DUSP6","KRAS","MAPK1","BICC1","ZMYM2","RICTOR","GAB1","TACC3","WAC","FGFR3")
ERDA_neg <- c("ERBB2","ERBB3","MET","PDGFRA","PDGFRB","MAP2K1","MAP2K2","BRAF","NRAS","GRB2",
              "PIK3CA","PIK3CB","PIK3R1","RPTOR","EXT1","EXT2","NDST2","HS6ST1","HS6ST2",
              "FGF1","FGF2","FGF5","FGF18","FGF21","ABCB1")
ERDA_core   <- c("FRS2","PLCG1","SHC1","PTPN11","ETV4","DUSP6","KRAS","MAPK1")
ERDA_bypass <- c("ERBB2","ERBB3","MET","PDGFRA","PDGFRB")

# Fexagratinib (pan-FGFR - compact biology-driven)
FEXA_pos <- c("FRS2","PLCG1","SHC1","PTPN11","ETV4","DUSP6","KRAS","MAPK1","FGFR2","FGFR3")
FEXA_neg <- c("ERBB2","ERBB3","MET","PDGFRA","PDGFRB","MAP2K1","MAP2K2","BRAF","PIK3CA","PIK3CB","ABCB1")
FEXA_core   <- c("FRS2","PLCG1","SHC1","PTPN11","ETV4","DUSP6","KRAS","MAPK1")
FEXA_bypass <- c("ERBB2","ERBB3","MET","PDGFRA","PDGFRB")

# Build per-drug indices (gene-z then mean z(pos) − mean z(neg))
score_panels <- function(vst_avg, panel_pos, panel_neg, core=NULL, bypass=NULL, out_stub) {
  all_genes <- unique(c(panel_pos, panel_neg, core %||% character(), bypass %||% character()))
  mat <- vst_avg |>
    dplyr::filter(gene %in% all_genes) |>
    tibble::column_to_rownames("gene") |>
    as.matrix()
  if (nrow(mat) == 0) stop(paste("No panel genes found for", out_stub))
  zmat <- t(scale(t(mat)))

  mcol <- function(gs) if (length(gs) == 0) rep(NA_real_, ncol(zmat)) else colMeans(zmat[intersect(gs, rownames(zmat)), , drop=FALSE], na.rm=TRUE)

  pos <- mcol(panel_pos)
  neg <- mcol(panel_neg)
  core_sc   <- if (length(core   %||% character())>0) mcol(core)   else rep(NA_real_, ncol(zmat))
  bypass_sc <- if (length(bypass %||% character())>0) mcol(bypass) else rep(NA_real_, ncol(zmat))

  out <- tibble::tibble(
    cell_line           = colnames(zmat),
    index_signed_z      = pos - neg,
    core_z              = core_sc,
    bypass_z            = bypass_sc,
    core_minus_bypass_z = core_sc - bypass_sc
  )
  readr::write_csv(out, file.path(out_root, paste0(out_stub, "_panel_scores_z.csv")))
  out
}

ERDA_scores <- score_panels(vst_avg, ERDA_pos, ERDA_neg, ERDA_core, ERDA_bypass, out_stub="ERDA")
FEXA_scores <- score_panels(vst_avg, FEXA_pos, FEXA_neg, FEXA_core, FEXA_bypass, out_stub="FEXA")

# Generic correlation + plotting (stamped) for one drug
analyze_drug <- function(drug_csv, drug_name, score_tbl, out_dir) {
  dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

  drug <- readr::read_csv(
    drug_csv,
    col_types = readr::cols(
      cell_line = readr::col_character(),
      IC50_nM   = readr::col_double(),
      AUC       = readr::col_double()
    )
  ) |>
    dplyr::mutate(AUC_death = AUC, AUC_viability = 1 - AUC)

  dat <- dplyr::inner_join(drug, score_tbl, by = "cell_line") |>
    dplyr::mutate(
      IC50_nM        = to_num(IC50_nM),
      AUC_death      = to_num(AUC_death),
      AUC_viability  = to_num(AUC_viability)
    )

  metrics <- c("index_signed_z","core_z","bypass_z","core_minus_bypass_z")
  metrics <- intersect(metrics, names(dat))
  endpoints <- c("IC50_nM","AUC_death","AUC_viability")

  # quick correlations
  corr_tbl <- purrr::map_dfr(metrics, function(m) {
    purrr::map_dfr(endpoints, function(e) {
      sub <- dat |> dplyr::select(all_of(c("cell_line", m, e))) |> tidyr::drop_na()
      tibble::tibble(
        metric    = m,
        endpoint  = e,
        n         = nrow(sub),
        spearman  = if (nrow(sub) >= 3) cor(sub[[m]], sub[[e]], method = "spearman") else NA_real_,
        pearson   = if (nrow(sub) >= 3) cor(sub[[m]], sub[[e]], method = "pearson")  else NA_real_
      )
    })
  })
  readr::write_csv(corr_tbl, file.path(out_dir, paste0(drug_name, "_correlations_quick.csv")))

  # detailed stats
  summarize_corr <- function(df, x, y) {
    sub <- df |> dplyr::select(x = !!rlang::sym(x), y = !!rlang::sym(y)) |> tidyr::drop_na()
    n   <- nrow(sub)
    pe  <- if (n >= 3) suppressWarnings(cor.test(sub$x, sub$y, method = "pearson"))  else NULL
    sp  <- if (n >= 3) suppressWarnings(cor.test(sub$x, sub$y, method = "spearman")) else NULL
    tibble::tibble(
      n            = n,
      pearson_r    = if (!is.null(pe)) unname(pe$estimate) else NA_real_,
      pearson_p    = if (!is.null(pe)) pe$p.value          else NA_real_,
      pearson_r2   = if (!is.null(pe)) unname(pe$estimate)^2 else NA_real_,
      pearson_ci_l = if (!is.null(pe) && !is.null(pe$conf.int)) pe$conf.int[1] else NA_real_,
      pearson_ci_u = if (!is.null(pe) && !is.null(pe$conf.int)) pe$conf.int[2] else NA_real_,
      spearman_rho = if (!is.null(sp)) unname(sp$estimate) else NA_real_,
      spearman_p   = if (!is.null(sp)) sp$p.value          else NA_real_
    )
  }

  corr_detailed <- purrr::map_dfr(metrics, function(m) {
    purrr::map_dfr(endpoints, function(e) {
      summarize_corr(dat, m, e) |> dplyr::mutate(metric = m, endpoint = e, .before = 1)
    })
  }) |>
    dplyr::mutate(
      n            = as.integer(n),
      dplyr::across(c(pearson_r, pearson_p, pearson_r2, pearson_ci_l, pearson_ci_u,
                      spearman_rho, spearman_p), as.numeric)
    )

  readr::write_csv(corr_detailed, file.path(out_dir, paste0(drug_name, "_correlations_detailed.csv")))

  # axis ranges: IC50 auto; AUC fixed to [0,1]
  y_ic50_range <- range(dat$IC50_nM, na.rm = TRUE)

  get_stats_label <- function(metric, endpoint, stats_df = corr_detailed) {
    row <- stats_df |> dplyr::filter(metric == !!metric, endpoint == !!endpoint)
    if (nrow(row) != 1) return("n = NA\nr = NA (p=NA),  r² = NA\nρ = NA (p=NA)")
    fmt <- function(x, d = 2) {
      x <- as.numeric(x)
      if (is.na(x)) "NA" else if (x < 1e-3) formatC(x, format = "e", digits = 1) else formatC(x, format = "f", digits = d)
    }
    paste0(
      "n = ", row$n,
      "\nr = ", fmt(row$pearson_r), " (p=", fmt(row$pearson_p), "),  r² = ", fmt(row$pearson_r2),
      "\nρ = ", fmt(row$spearman_rho), " (p=", fmt(row$spearman_p), ")"
    )
  }

  plot_one <- function(xvar, yvar, data = dat) {
    df <- data |>
      dplyr::select(cell_line, x = !!rlang::sym(xvar), y = !!rlang::sym(yvar)) |>
      tidyr::drop_na()

    df_lab <- df |>
      dplyr::group_by(cell_line) |>
      dplyr::summarise(x = mean(x, na.rm = TRUE), y = mean(y, na.rm = TRUE), .groups = "drop")

    stats_lab <- get_stats_label(metric = xvar, endpoint = yvar, stats_df = corr_detailed)

    # >>> CHANGE HERE: fix all AUC to [0,1], keep IC50 automatic <<<
    y_limits <- if (yvar == "IC50_nM") y_ic50_range else
                if (yvar %in% c("AUC_death","AUC_viability")) c(0, 1) else NULL

    n_labs <- nrow(df_lab)
    txt_sz <- if (n_labs <= 10) 3.8 else if (n_labs <= 20) 3.2 else if (n_labs <= 35) 2.8 else 2.6
    base_w <- if (n_labs <= 12) 6.6 else if (n_labs <= 24) 7.4 else 8.2
    base_h <- if (n_labs <= 12) 4.6 else if (n_labs <= 24) 5.1 else 5.6

    subtitle <- if (xvar == "index_signed_z") {
      "Panel index = mean z(pro-sensitivity) − mean z(resistance/bypass)"
    } else if (xvar == "core_minus_bypass_z") {
      "Core FGFR signal (z) − bypass RTK (z)"
    } else ""

    p_main <- ggplot() +
      geom_point(data = df, aes(x = x, y = y), size = 2.4, alpha = 0.45) +
      geom_point(data = df_lab, aes(x = x, y = y), size = 2.8, alpha = 0.9) +
      ggrepel::geom_text_repel(
        data = df_lab, aes(x = x, y = y, label = cell_line),
        max.overlaps = Inf, size = txt_sz, label.size = NA,
        label.padding = grid::unit(0.15, "lines"),
        box.padding   = grid::unit(0.35, "lines"),
        point.padding = grid::unit(0.15, "lines"),
        min.segment.length = 0, segment.size = 0.25,
        seed = 42, force = 0.6, force_pull = 0.4
      ) +
      geom_smooth(data = df, aes(x = x, y = y), method = "lm", se = FALSE, linewidth = 0.6) +
      { if (is.null(y_limits)) scale_y_continuous() else scale_y_continuous(limits = y_limits) } +
      labs(x = xvar, y = yvar,
           title = paste(drug_name, ":", yvar, "vs", xvar),
           subtitle = subtitle) +
      theme_minimal(base_size = 12) +
      theme(plot.margin = margin(10, 10, 10, 10), legend.position = "none")

    # compact side stamp (centered)
    nl   <- length(strsplit(stats_lab, "\n")[[1]])
    s_w  <- 0.18
    s_h  <- min(0.45, max(0.22, 0.055 * nl + 0.06))
    s_y  <- (1 - s_h) / 2

    stamp_plot <- ggplot() +
      coord_cartesian(xlim = c(0, 1), ylim = c(0, 1), expand = FALSE) +
      theme_void() +
      annotate("rect", xmin = 0, xmax = 1, ymin = 0, ymax = 1,
               fill = "white", alpha = 1, colour = "grey85", linewidth = 0.35) +
      annotate("text", x = 0.04, y = 0.5, hjust = 0, vjust = 0.5,
               label = stats_lab, size = 2.4, lineheight = 1.05)

    p_final <- cowplot::ggdraw() +
      cowplot::draw_plot(p_main,     x = 0,        y = 0,   width = 1 - s_w, height = 1, hjust = 0, vjust = 0) +
      cowplot::draw_plot(stamp_plot, x = 1 - s_w,  y = s_y, width = s_w,     height = s_h, hjust = 0, vjust = 0)

    dir.create(file.path(out_dir, "plots"), showWarnings = FALSE, recursive = TRUE)
    fn <- file.path(out_dir, "plots",
                    paste0(yvar, "_vs_", xvar, "_ONE_LABEL_PER_CELL_LINE.png"))
    ggsave(fn, p_final, width = base_w + 0.9, height = base_h, dpi = 600)
    invisible(p_final)
  }

  for (m in metrics) for (e in endpoints) plot_one(m, e, data = dat)

  message("Done: ", drug_name, " → ", out_dir,
          "\n- *_panel_scores_z.csv (in project root for this run)",
          "\n- ", drug_name, "_correlations_quick.csv",
          "\n- ", drug_name, "_correlations_detailed.csv",
          "\n- plots/*_ONE_LABEL_PER_CELL_LINE.png")
}

# Run per drug
analyze_drug(erda_csv, "Erdafitinib",  ERDA_scores, file.path(out_root, "erdafitinib"))
analyze_drug(fexa_csv, "Fexagratinib", FEXA_scores, file.path(out_root, "fexagratinib"))

```

