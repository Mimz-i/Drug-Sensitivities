---
title: "Mim's RNSseq STAR_RSEM ENSEMBL DESEq2 and GSEA for drug sensitivities of STS cell lines"
output: html_document
editor_options: 
  chunk_output_type: inline
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.


# Load packages from library
```{r}
library(DESeq2)
library(tximport)
library(readr)
library(dplyr)
library(tidyr)
library(wesanderson)
library(pheatmap)
library(ggplot2)
library(genefilter)
library(org.Hs.eg.db)
library(data.table); library(limma); library(fgsea); library(msigdbr)
library(AnnotationDbi); library(GSVA); library(ReactomePA)
library(STRINGdb); library(igraph); library(matrixStats)


```


#Read the sample information into R
```{r}
out_root <- file.path(getwd(), paste0("results_STS_", format(Sys.Date(), "%Y%m%d")))
dir.create(out_root, showWarnings = FALSE, recursive = TRUE)

sampleinfo <- read_csv("sampleinfo_STS_DrugSens_2025.csv")

if (interactive()) View(sampleinfo)
```



#The resulting object is a “list” structure in R which contains a number of components that we can access using a $ operator. The raw counts can be found using txi$counts. The names of each column are the sample names. If we had not defined the names of the quant_files vector the columns would just have numbers which would not be useful for downstream analysis.
```{r}
rsem_counts <- read_tsv("left_merged_STS_Batches_1_2_gene_counts.tsv")
gene_names <- pull(rsem_counts, gene_id)

rsem_counts <- dplyr::select(rsem_counts, -c(1:2)) %>% as.matrix()
rownames(rsem_counts) <- gene_names


# Filter (>=10 counts in >=4 samples)
min_samps <- 4
keep_filt <- rowSums(rsem_counts >= 10) >= min_samps
message(sprintf("Keeping %d / %d genes (>=10 in >=%d samples).",
                sum(keep_filt), nrow(rsem_counts), min_samps))
rsem_counts <- rsem_counts[keep_filt, , drop = FALSE]

# Factors
sampleinfo$Batch     <- factor(sampleinfo$Batch)
sampleinfo$cell_type <- factor(sampleinfo$cell_type)

#Make sure colData rownames match your count matrix columns before building any DESeqDataSet:
rownames(sampleinfo) <- sampleinfo$name  # or whatever column matches
stopifnot(all(colnames(rsem_counts) == rownames(sampleinfo)))


dds <- DESeqDataSetFromMatrix(
  countData = round(rsem_counts),
  colData   = sampleinfo,
  design    = ~ Batch + cell_type
)
```



```{r}
#Annotate a dds object with SYMBOL names for later use.

ens_cell_type <- rownames(rsem_counts)


symbols <- mapIds(org.Hs.eg.db, keys = ens_cell_type,
  column = c('SYMBOL'), keytype = 'ENSEMBL')
  symbols <- symbols[!is.na(symbols)]
  symbols <- symbols[match(rownames(rsem_counts), names(symbols))]
  rownames(rsem_counts) <- symbols
  keep <- !is.na(rownames(rsem_counts))
  rsem_counts_symbol <- rsem_counts[keep,]
  

#After mapping to symbols, there will likely be duplicate gene names. Collapse or make them unique before DESeqDataSetFromMatrix:  
rsem_counts_symbol <- rowsum(rsem_counts_symbol, group = rownames(rsem_counts_symbol))
  


# Setup & model fit
suppressPackageStartupMessages({
  library(DESeq2)
  library(tibble)
  library(dplyr)
})

# If needed for lfcShrink(type="ashr")
if (!requireNamespace("ashr", quietly = TRUE)) {
  install.packages("ashr")
}

# Ensure factors are clean
sampleinfo$cell_type <- droplevels(factor(sampleinfo$cell_type))
sampleinfo$Batch     <- droplevels(factor(sampleinfo$Batch))

dds_symbol <- DESeqDataSetFromMatrix(
  countData = round(rsem_counts_symbol),
  colData   = sampleinfo,
  design    = ~ Batch + cell_type
)

dds_symbol <- DESeq(dds_symbol)

# Optional: overall results table (last level vs reference, not a pairwise contrast)
res_de_cell_type_symbol <- results(dds_symbol, tidy = TRUE)

# Build all unique pairwise contrasts
cell_lvls <- levels(colData(dds_symbol)$cell_type)
pairs <- combn(cell_lvls, 2, simplify = FALSE)  # list of c(A, B)

# Containers
pair_res_list      <- list()  # results()
pair_lfcshrink_list <- list() # lfcShrink()

# Output dir
out_dir <- "deseq2_pairwise_cell_type"
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

# Loop over all pairs
for (pb in pairs) {
  A <- pb[1]
  B <- pb[2]
  cname <- paste0(A, "_vs_", B)

  # Raw DE results (tidy)
  res_ab <- results(
    dds_symbol,
    contrast = c("cell_type", A, B),
    alpha    = 0.05,
    tidy     = TRUE
  ) %>%
    mutate(contrast = cname)

  pair_res_list[[cname]] <- res_ab
  write.csv(res_ab, file.path(out_dir, paste0("DE_", cname, "_results.csv")), row.names = FALSE)

  # Shrunk LFCs (ashr). Returns a DESeqResults with rownames = gene IDs
  lfc_ab <- lfcShrink(
    dds     = dds_symbol,
    contrast = c("cell_type", A, B),
    type    = "ashr"
  )

  lfc_ab_df <- as.data.frame(lfc_ab) %>%
    rownames_to_column(var = "row") %>%
    mutate(contrast = cname)

  pair_lfcshrink_list[[cname]] <- lfc_ab_df
  write.csv(lfc_ab_df, file.path(out_dir, paste0("DE_", cname, "_LFCshrink_ashr.csv")), row.names = FALSE)
}

# (Optional) save everything together as RDS
saveRDS(
  list(
    raw_results   = pair_res_list,
    lfc_shrunk    = pair_lfcshrink_list,
    overall_tidy  = res_de_cell_type_symbol
  ),
  file = file.path(out_dir, "all_pairwise_DESeq2_cell_type_results.rds")
)


```



#Quality control of the imported counts. Use DESeq2 library to analyse dataset. Counts, metadata and a design for the experiment need to be specified. Printing the contents of dds to the screen gives details of how the data are represented.
#colData will display the meta data that has been stored with the object.
```{r}

colData(dds)

```

#The metadata columns can also be re-assigned. This useful in this case because we can see that condition is not stored as a factor, which could cause problems later on when we want to use condition in the differential expression.
```{r}

dds$chem <- as.factor(dds$chem)
dds$rad <- as.factor(dds$rad)
dds$cell_type <- as.factor(dds$cell_type)
dds$Replicate <- as.numeric(dds$Replicate)
dds$Lineage <- as.factor(dds$Lineage)
dds$name <- as.factor(dds$name)

colData(dds)

```



```{r}
sum(counts(dds)[,1])

colSums(counts(dds))



boxplot(counts(dds))

mutate(sampleinfo, LibSize = colSums(assay(dds))/1e5) %>% 
  ggplot(aes(x = name, y = LibSize)) + geom_col(fill="steelblue") + geom_hline(yintercept = 200,col="red",lty=2) + scale_x_discrete(guide = guide_axis(angle = 45))

```



```{r}
dds_SF <- estimateSizeFactors(dds)
dds_Disp <- estimateDispersions(dds_SF)

plotDispEsts(dds_Disp)
```



#Visualising count distributions. We can use the vst or rlog function from DESeq2to compensate for the effect of different library sizes and put the data on the log2  scale. The effect is to remove the dependence of the variance on the mean, particularly the high variance of the logarithm of count data when the mean is low. 
```{r}
vsd <- vst(dds,blind=FALSE)
rld <- rlog(dds, blind = FALSE)



# In the above function calls, we specified blind = FALSE, which means that differences between cell lines and treatment (the variables in the design) will not contribute to the expected variance-mean trend of the experiment. The experimental design is not used directly in the transformation, only in estimating the global amount of variability in the counts. For a fully unsupervised transformation, one can set blind = TRUE (which is the default). To show the effect of the transformation, in the figure below we plot the first sample against the second, first simply using the log2 function (after adding 1, to avoid taking the log of zero), and then using the VST and rlog-transformed values. For the log2 approach, we need to first estimate size factors to account for sequencing depth, and then specify normalized=TRUE. Sequencing depth correction is done automatically for the vst and rlog.

df <- bind_rows(
  as_data_frame(log2(counts(dds_SF, normalized=TRUE)[, 1:2]+1)) %>%
         mutate(transformation = "log2(x + 1)"),
  as_data_frame(assay(vsd)[, 1:2]) %>% mutate(transformation = "vst"),
  as_data_frame(assay(rld)[, 1:2]) %>% mutate(transformation = "rlog"))
  
colnames(df)[1:2] <- c("x", "y")  

lvls <- c("log2(x + 1)", "vst", "rlog")
df$transformation <- factor(df$transformation, levels=lvls)

ggplot(df, aes(x = x, y = y)) + geom_hex(bins = 80) +
  coord_fixed() + facet_grid( . ~ transformation) 



#QC: VST + PCA; viz-only batch removal
#Quick check whether batch drives clustering; use removeBatchEffect only for plots—not for DE tests.

rsem_counts <- read_tsv("left_merged_STS_Batches_1_2_gene_counts.tsv")
gene_names <- pull(rsem_counts, gene_id)

rsem_counts <- dplyr::select(rsem_counts, -c(1:2)) %>% as.matrix()
rownames(rsem_counts) <- gene_names


# Filter (>=10 counts in >=4 samples)
min_samps <- 4
keep_filt <- rowSums(rsem_counts >= 10) >= min_samps
message(sprintf("Keeping %d / %d genes (>=10 in >=%d samples).",
                sum(keep_filt), nrow(rsem_counts), min_samps))
rsem_counts <- rsem_counts[keep_filt, , drop = FALSE]

# Factors
sampleinfo$Batch     <- factor(sampleinfo$Batch)
sampleinfo$cell_type <- factor(sampleinfo$cell_type)

#Make sure colData rownames match your count matrix columns before building any DESeqDataSet:
rownames(sampleinfo) <- sampleinfo$name  # or whatever column matches
stopifnot(all(colnames(rsem_counts) == rownames(sampleinfo)))
dds_qc <- DESeqDataSetFromMatrix(
  countData = round(rsem_counts),
  colData   = sampleinfo,
  design    = ~ Batch + cell_type
)

vst_qc <- vst(dds_qc, blind = TRUE)

p1 <- plotPCA(vst_qc, intgroup = c("cell_type", "Batch"), ntop = 2000) + ggtitle("PCA (VST, uncorrected)")
ggsave(file.path(out_root, "PCA_vst_uncorrected.pdf"), p1, width=6, height=5)

vst_bc <- removeBatchEffect(assay(vst_qc),
                            batch  = colData(vst_qc)$Batch,
                            design = model.matrix(~ cell_type, data = as.data.frame(colData(vst_qc))))
vst_bc_se <- vst_qc; assay(vst_bc_se) <- vst_bc

p2 <- plotPCA(vst_bc_se, intgroup="Batch") + ggtitle("PCA (VST, batch removed)")
ggsave(file.path(out_root, "PCA_vst_batch_removed.pdf"), p2, width=6, height=5)

p3 <- plotPCA(vst_bc_se, intgroup = c("cell_type", "Batch"), ntop = 2000) +
  ggtitle("PCA (VST, batch-removed with cell type as co-factor)")
ggsave(file.path(out_root, "PCA_vst_batch_removed_celltype.pdf"), p3, width=6, height=5)


```



```{r}
# Get log2 counts
vsd <- vst(dds,blind=TRUE)

# Check distributions of samples using boxplots
boxplot(assay(vsd), xlab="", ylab="Log2 counts per million",las=2,main="Normalised Distributions")

abline(h=median(assay(vsd)), col="blue")

```


# Principal components Analysis (PCA).An example of an unsupervised analysis, where we don’t need to specify the groups. If the experiment is well-controlled and has worked well, what we hope to see is that the greatest sources of variation in the data correspond to the treatments/groups we are interested in. It is also an incredibly useful tool for quality control and checking for outliers.
```{r}
library("ggrepel")

plotPCA(vsd,intgroup="cell_type")

PCAplot <- plotPCA(vsd,intgroup="cell_type",returnData = TRUE) %>% 
  dplyr::rename(cell_line = cell_type) %>% 
  left_join(sampleinfo) %>% 
  ggplot(aes(x = PC1, y = PC2,col="group")) + geom_point(size=2)

PCAplot


PCAplot + scale_color_manual(values = c("#D55E00", "#D41159", "#000000", "#117733", "#332288", "#FF00FF", "#00CC33", "#0000FF", "#FFC20A"))+ theme(axis.text = element_text(size = 15))+ theme(axis.title = element_text(size = 15))+ theme(legend.text = element_text(size = 15)) + theme(legend.title = element_text(size = 15)) 


pcaData_cell_type = plotPCA(vsd, intgroup="cell_type",returnData=TRUE)
percentVar = round(100 * attr(pcaData_cell_type, "percentVar"))

png("DGE_PCA-vst Cell Type.RSEM.png", width=7, height=7, units = "in", res = 300)
ggplot(pcaData_cell_type, aes(PC1, PC2, colour = cell_type)) + 
geom_point(size = 2) + theme_bw() + 
scale_color_manual(values = c("#D55E00", "#D41159", "#000000", "#117733", "#332288", "#FF00FF", "#00CC33", "#0000FF", "#FFC20A")) +
geom_text_repel(aes(label = cell_type), nudge_x = -1, nudge_y = 0.2, size = 2) +
ggtitle("Principal Component Analysis (PCA) STS Cell Lines", subtitle = "vst transformation") +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance"))

```


#It is a good idea to save the results of the pre-processing so we don’t have to repeat it every time.
```{r}

dir.create("Robjects_cell_type/",showWarnings = FALSE)
saveRDS(dds, file="Robjects_cell_type/dds.rds")


dir.create("Robjects_cell_type/",showWarnings = FALSE)
saveRDS(dds_symbol, file="Robjects_cell_type/dds_symbol.rds") 

```

#Retrieve saved R object to dataset
```{r}
dds <- readRDS("Robjects_cell_type/dds.rds")
```


#DESeq workflow. Set design for DESeq object, in this case we want to look at differential expression amongst the different cell types while correcting for batch effects.
```{r}
colData(dds)
design(dds) <- ~ Batch + cell_type
de_cell_type <- DESeq(dds)
```



```{r}
suppressPackageStartupMessages({
  library(DESeq2)
  library(dplyr)
  library(readr)
  library(tibble)
  library(ggplot2)
})

# Load fitted DESeqDataSet
dds <- readRDS("Robjects_cell_type/dds.rds")

# Fit with desired design
design(dds) <- ~ Batch + cell_type
de_cell_type <- DESeq(dds)

# Pairwise contrasts
cell_lvls <- levels(colData(de_cell_type)$cell_type)
stopifnot(length(cell_lvls) >= 2)
pairs <- combn(cell_lvls, 2, simplify = FALSE)

# Output folders
dir.create("de_analysis", showWarnings = FALSE, recursive = TRUE)
dir.create("Robjects",    showWarnings = FALSE, recursive = TRUE)
dir.create("plots",       showWarnings = FALSE, recursive = TRUE)

# Optional: shrunken LFCs for MA plots
use_ashr <- requireNamespace("ashr", quietly = TRUE)

# Collect counts per contrast
de_counts <- list()

for (pb in pairs) {
  A <- pb[1]; B <- pb[2]
  base <- paste0("cell_type_", A, "_vs_", B)

  # DESeq results (controls padj/pvalue)
  res <- results(de_cell_type, contrast = c("cell_type", A, B), alpha = 0.05)

  res_df <- as.data.frame(res) %>%
    rownames_to_column(var = "gene") %>%
    as_tibble()

  # Remove NAs before saving
  res_all_nona <- res_df %>% tidyr::drop_na(padj)
  res_sig_nona <- res_df %>% tidyr::drop_na(padj) %>% filter(padj < 0.05)

  # Save ALL and SIG (NA-removed)
  res_all_nona %>%
    arrange(padj) %>%
    write_csv(file.path("de_analysis", paste0(base, "_DESeq_all.csv")))
  write_csv(res_sig_nona,
            file.path("de_analysis", paste0(base, "_DESeq_sig.csv")))

  # Save raw DESeqResults object
  saveRDS(res, file = file.path("Robjects", paste0(base, ".rds")))

  # Counts
  n_de_p     <- res_df %>% tidyr::drop_na(pvalue) %>% summarize(n = sum(pvalue < 0.05)) %>% pull(n)
  n_de_padj  <- res_df %>% tidyr::drop_na(padj)   %>% summarize(n = sum(padj   < 0.05)) %>% pull(n)

  # For fold-change thresholding, use the plotting object (shrunken if available)
  plot_res <- if (use_ashr) {
    lfcShrink(de_cell_type, contrast = c("cell_type", A, B), type = "ashr")
  } else {
    res
  }
  plot_df <- as.data.frame(plot_res) %>%
    rownames_to_column(var = "gene") %>%
    as_tibble() %>%
    # keep padj from plot_res (present) for consistent colouring
    tidyr::drop_na(baseMean, log2FoldChange)  # drop rows that cannot be plotted

  # Add categories for colouring
  plot_df <- plot_df %>%
    mutate(
      x = log10(baseMean + 1),
      cat = dplyr::case_when(
        !is.na(padj) & padj < 0.05 & log2FoldChange >  0.58 ~ "sig_up_fc",
        !is.na(padj) & padj < 0.05 & log2FoldChange < -0.58 ~ "sig_down_fc",
        !is.na(padj) & padj < 0.05                         ~ "sig_padj_only",
        TRUE                                               ~ "ns"
      ),
      cat = factor(cat, levels = c("ns","sig_padj_only","sig_up_fc","sig_down_fc"))
    )

  n_up   <- sum(plot_df$cat == "sig_up_fc", na.rm = TRUE)
  n_down <- sum(plot_df$cat == "sig_down_fc", na.rm = TRUE)

  de_counts[[base]] <- tibble(
    contrast = paste0(A, "_vs_", B),
    n_DE_p_lt_0_05    = n_de_p,
    n_DE_padj_lt_0_05 = n_de_padj,
    n_DE_up_LFCgt0_58_padjlt0_05 = n_up,
    n_DE_down_LFCltm0_58_padjlt0_05 = n_down
  )

  # Colour-based MA plot with colour-matched labels
  cols <- c(
    ns             = "grey80",
    sig_padj_only  = "orange",
    sig_up_fc      = "firebrick",
    sig_down_fc    = "royalblue"
  )

  p <- ggplot(plot_df, aes(x = x, y = log2FoldChange, colour = cat)) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    geom_hline(yintercept = c(-0.58, 0.58), linetype = "dotted") +
    geom_point(size = 1.2, alpha = 0.8) +
    scale_color_manual(
      name = NULL,
      values = cols,
      labels = c(
        ns = "Not significant",
        sig_padj_only = "padj < 0.05",
        sig_up_fc = "padj < 0.05 & LFC > 0.58",
        sig_down_fc = "padj < 0.05 & LFC < -0.58"
      )
    ) +
    labs(
      title = paste0(base, if (use_ashr) " (ashr shrinkage)" else " (unshrunken)"),
      subtitle = sprintf("# DE: p<0.05=%d | padj<0.05=%d | up>|0.58|=%d | down>|0.58|=%d",
                         n_de_p, n_de_padj, n_up, n_down),
      x = "log10(baseMean + 1)",
      y = "log2 fold change"
    ) +
    theme_minimal(base_size = 12) +
    theme(legend.position = "right")

  # Add colour-matched text labels inside the plot area (top-right)
  # Use Inf coordinates with hjust/vjust to anchor
  p <- p +
    annotate("text", x = Inf, y = Inf,
             label = paste0("UP (padj<0.05 & LFC>0.58): ", n_up),
             hjust = 1.02, vjust = 2.3, colour = cols["sig_up_fc"], size = 4) +
    annotate("text", x = Inf, y = Inf,
             label = paste0("DOWN (padj<0.05 & LFC< -0.58): ", n_down),
             hjust = 1.02, vjust = 3.5, colour = cols["sig_down_fc"], size = 4) +
    annotate("text", x = Inf, y = Inf,
             label = paste0("padj<0.05: ", n_de_padj),
             hjust = 1.02, vjust = 4.7, colour = cols["sig_padj_only"], size = 4)

  ggsave(file.path("plots", paste0(base, "_MA.png")), p, width = 8, height = 6, dpi = 150)
}

# Save summary counts
bind_rows(de_counts) %>%
  arrange(desc(n_DE_padj_lt_0_05)) %>%
  write_csv(file.path("de_analysis", "DE_counts_by_contrast.csv"))

message("Done. NA-removed tables in 'de_analysis/', plots in 'plots/', DESeqResults in 'Robjects/'.")

```


#Add heatmap clustering per contrast, using VST-transformed counts with viz-only batch removal, and saving heatmaps for: - Top DE genes per contrast (up to top_n up and top_n down at padj < 0.05 & |LFC| > 0.58), - a  fallback all significant (padj < 0.05) heatmap if too few pass the LFC threshold,- both all samples and contrast-only samples (A/B) views.
```{r}
suppressPackageStartupMessages({
  library(DESeq2); library(dplyr); library(tibble)
  library(pheatmap); library(limma); library(matrixStats)
})

# VST (viz-only batch removal)
vst_all <- vst(de_cell_type, blind = FALSE)
vst_mat <- assay(vst_all)
vst_mat_bc <- removeBatchEffect(
  vst_mat,
  batch  = colData(vst_all)$Batch,
  design = model.matrix(~ cell_type, data = as.data.frame(colData(vst_all)))
)

# Annotation & palette
ann_col <- as.data.frame(colData(vst_all)[, c("cell_type","Batch")])
rownames(ann_col) <- colnames(vst_mat_bc)
pal <- colorRampPalette(c("navy","white","firebrick3"))(101)

dir.create("plots/heatmaps", showWarnings = FALSE, recursive = TRUE)

zscore <- function(m){ m2 <- t(scale(t(m))); m2[is.na(m2)] <- 0; m2 }

top_n <- 50  # up to 50 up + 50 down when available

sanitize <- function(x) gsub("[^A-Za-z0-9._-]+", "_", x)

for (pb in pairs) {
  A <- pb[1]; B <- pb[2]
  base <- paste0("cell_type_", sanitize(A), "_vs_", sanitize(B))

  # DE results for this contrast
  res_df <- results(de_cell_type, contrast = c("cell_type", A, B), alpha = 0.05) |>
    as.data.frame() |> rownames_to_column("gene") |> as_tibble()

  # primary selection: padj<0.05 & |LFC|>0.58
  sig_lfc <- res_df |> filter(!is.na(padj), padj < 0.05, !is.na(log2FoldChange), abs(log2FoldChange) > 0.58)
  top_up  <- sig_lfc |> arrange(desc(log2FoldChange)) |> slice_head(n = top_n) |> pull(gene)
  top_dn  <- sig_lfc |> arrange(     log2FoldChange ) |> slice_head(n = top_n) |> pull(gene)
  genes_primary <- unique(c(top_up, top_dn))

  # fallback 1: padj<0.05 best (up to 100)
  if (length(genes_primary) < 10) {
    sig_any <- res_df |> filter(!is.na(padj), padj < 0.05) |>
      arrange(padj, desc(abs(log2FoldChange))) |> slice_head(n = 100) |> pull(gene)
    genes_use <- unique(sig_any)
    tag <- if (length(genes_use) > 0) "sig_padj_only" else NA
  } else {
    genes_use <- genes_primary; tag <- "sig_padj_LFC"
  }

  # fallback 2: if still none, take top-variance genes across A/B samples (always plots)
  cols_ab <- colnames(vst_mat_bc)[colData(vst_all)$cell_type %in% c(A,B)]
  if (length(genes_use) == 0) {
    ab_mat <- vst_mat_bc[, cols_ab, drop = FALSE]
    v <- rowVars(ab_mat)
    genes_use <- names(sort(v, decreasing = TRUE))[seq_len(min(100, length(v)))]
    tag <- "topvar_AB"
  }

  # intersect with VST matrix rownames
  genes_use <- intersect(genes_use, rownames(vst_mat_bc))
  if (length(genes_use) == 0) {
    message("No genes found to plot for ", base, " — skipping."); next
  }

  # matrices
  mat_all <- vst_mat_bc[genes_use, , drop = FALSE]
  mat_ab  <- mat_all[, cols_ab, drop = FALSE]

  mat_all_z <- zscore(mat_all)
  mat_ab_z  <- zscore(mat_ab)

  ann_all <- ann_col
  ann_ab  <- ann_col[colnames(mat_ab_z), , drop = FALSE]

  # save explicitly via devices (prevents saving the “last ggplot”)
  f_all <- file.path("plots/heatmaps", paste0(base, "_", tag, "_ALL.png"))
  png(f_all, width = 2400, height = 2400, res = 300)
  pheatmap(mat_all_z, color = pal, show_rownames = FALSE, show_colnames = TRUE,
           annotation_col = ann_all, clustering_distance_rows = "euclidean",
           clustering_distance_cols = "euclidean", clustering_method = "complete",
           main = paste0(base, " — heatmap (", tag, "), all samples"))
  dev.off()

  f_ab <- file.path("plots/heatmaps", paste0(base, "_", tag, "_", sanitize(A), "_vs_", sanitize(B), ".png"))
  png(f_ab, width = 2000, height = 2000, res = 300)
  pheatmap(mat_ab_z, color = pal, show_rownames = FALSE, show_colnames = TRUE,
           annotation_col = ann_ab, clustering_distance_rows = "euclidean",
           clustering_distance_cols = "euclidean", clustering_method = "complete",
           main = paste0(base, " — heatmap (", tag, "), ", A, " vs ", B))
  dev.off()

  message("Saved: ", basename(f_all), " and ", basename(f_ab))
}

```


```{r}
suppressPackageStartupMessages({
  library(DESeq2)
  library(pheatmap)
  library(RColorBrewer)
})

# Use the fitted object if present; otherwise use dds
obj <- if (exists("de_cell_type")) de_cell_type else dds

# VST for distance computation
vsd <- vst(obj, blind = FALSE)

# Labels from colData$name (make unique just in case)
if (!"name" %in% colnames(colData(vsd))) {
  stop("'name' column not found in colData(dds).")
}
labels <- make.unique(as.character(colData(vsd)$name))

# Sample-to-sample (Euclidean) distances on VST expression
sample_dists <- dist(t(assay(vsd)))
dist_mat <- as.matrix(sample_dists)

# Apply labels
rownames(dist_mat) <- labels
colnames(dist_mat) <- labels

# Column annotations
ann_col <- data.frame(
  cell_type = factor(colData(vsd)$cell_type),
  Batch     = factor(colData(vsd)$Batch),
  row.names = labels
)

# High-contrast legend colors
# Okabe–Ito palette (colorblind-friendly, very contrasty)
okabe_ito <- c("#000000","#E69F00","#56B4E9","#009E73",
               "#F0E442","#0072B2","#D55E00","#CC79A7")

# cell_type colors (extend if >8 levels)
ct_lvls <- levels(ann_col$cell_type)
if (length(ct_lvls) <= length(okabe_ito)) {
  ct_cols <- okabe_ito[seq_along(ct_lvls)]
} else {
  # extend with distinct dark HCL hues
  extra <- grDevices::hcl.colors(length(ct_lvls) - length(okabe_ito), palette = "Dark 3")
  ct_cols <- c(okabe_ito, extra)
}
names(ct_cols) <- ct_lvls

# Batch colors (greys so cell_type stands out)
b_lvls <- levels(ann_col$Batch)
b_cols <- setNames(colorRampPalette(c("#4B0082","#FF00FF"))(length(b_lvls)), b_lvls)

ann_colors <- list(
  cell_type = ct_cols,
  Batch     = b_cols
)
# -------------------------------------------------

# Heatmap palette for distances
pal <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)

# Save the heatmap (use pheatmap's filename arg, not ggsave)
dir.create("plots", showWarnings = FALSE, recursive = TRUE)
pheatmap(
  dist_mat,
  color = pal,
  clustering_distance_rows = sample_dists,
  clustering_distance_cols = sample_dists,
  annotation_col = ann_col,
  annotation_colors = ann_colors,        # << apply custom legend colors
  show_rownames = TRUE,
  show_colnames = TRUE,
  main = "Sample-to-sample distances (VST)",
  cellwidth  = 18,    # width of each column (px-ish)
  cellheight = 14,    # height of each row (px-ish)
  fontsize_row = 9,   # row label text size
  fontsize_col = 9,   # column label text size
  treeheight_row = 50,
  treeheight_col = 50,
  angle_col = 45,
  filename = file.path("plots", "sample_distance_heatmap.png"),
  width = 13, height = 10
)

```





```{r}
suppressPackageStartupMessages({ library(readr); library(dplyr); library(stringr) })

panels_dir <- "drug_gene_panels"
dir.create(panels_dir, showWarnings = FALSE, recursive = TRUE)

write_gmt <- function(list_of_sets, path){
  dir.create(dirname(path), showWarnings = FALSE, recursive = TRUE)
  con <- file(path, "w"); on.exit(close(con))
  for (nm in names(list_of_sets)) {
    genes <- unique(na.omit(list_of_sets[[nm]]))
    if (!length(genes)) next
    writeLines(paste(c(nm, "NA", genes), collapse = "\t"), con)
  }
  message("Wrote GMT: ", path)
}

# Shared FGFR blocks
FGFR_adaptors  <- c("FRS2","GRB2","SOS1","GAB1","SHC1","PLCG1")
FGFR_lig_par   <- c("FGF1","FGF2","FGF3","FGF4","FGF5","FGF6","FGF7","FGF8","FGF9","FGF10","FGF18","FGF20")
FGFR_lig_end   <- c("FGF19","FGF21","FGF23","KLB","KL")
FGFR_MAPK      <- c("HRAS","KRAS","NRAS","RAF1","BRAF","MAP2K1","MAP2K2","MAPK1","MAPK3","DUSP6","SPRY2","SPRY4","ETV4","ETV5")
FGFR_PI3K      <- c("PIK3CA","PIK3CB","PIK3CD","PIK3R1","PTEN","AKT1","AKT2","AKT3","MTOR","RPS6KB1","RPS6KB2")
FGFR_STAT_PLC  <- c("STAT1","STAT3","STAT5A","STAT5B","PLCG1")
FGFR_feedback  <- c("SPRY2","SPRY4","DUSP6","IL17RD")
FGFR_fusions   <- c("TACC3","BICC1","BAG4","ZMYM2","NDC80","AFF3","CCDC6","KIAA1217","KIAA1598")
RTK_crosstalk  <- c("ERBB2","ERBB3","MET","PDGFRA","PDGFRB")

build_fgfr_drug <- function(drug, receptors){
  out_csv <- file.path(panels_dir, sprintf("%s_gene_panel.csv", drug))
  gmt_dir <- file.path(panels_dir, sprintf("%s_gmts", drug))
  dir.create(gmt_dir, showWarnings = FALSE, recursive = TRUE)

  panel <- unique(c(
    receptors, FGFR_adaptors, FGFR_lig_par, FGFR_lig_end,
    FGFR_MAPK, FGFR_PI3K, FGFR_STAT_PLC, FGFR_feedback,
    FGFR_fusions, RTK_crosstalk
  ))
  tibble(symbol = sort(panel)) %>% write_csv(out_csv)
  message("Wrote panel CSV: ", out_csv)

  gmt_core <- list(
    FGFR_RECEPTORS            = receptors,
    FGFR_ADAPTORS             = FGFR_adaptors,
    FGFR_LIGANDS_PARACRINE    = FGFR_lig_par,
    FGFR_LIGANDS_ENDOCRINE    = FGFR_lig_end,
    FGFR_MAPK_AXIS            = FGFR_MAPK,
    FGFR_PI3K_AKT_MTOR_AXIS   = FGFR_PI3K,
    FGFR_STAT_PLC_AXIS        = FGFR_STAT_PLC,
    FGFR_NEGATIVE_FEEDBACK    = FGFR_feedback
  )
  write_gmt(gmt_core, file.path(gmt_dir, "FGFR_core_and_pathway.symbols.gmt"))
  write_gmt(list(FGFR_ONCOGENIC_FUSION_PARTNERS = FGFR_fusions),
            file.path(gmt_dir, "FGFR_fusions.symbols.gmt"))
  write_gmt(list(RTK_CROSSTALK_MINIMAL = RTK_crosstalk),
            file.path(gmt_dir, "FGFR_rtk_crosstalk.symbols.gmt"))
}

# Fexagratinib (FGFR1/2/3; FGFR4 excluded)
build_fgfr_drug("Fexagratinib", receptors = c("FGFR1","FGFR2","FGFR3"))

# Erdafitinib (FGFR1/2/3/4 included)
build_fgfr_drug("Erdafitinib",  receptors = c("FGFR1","FGFR2","FGFR3","FGFR4"))

# Carfilzomib (proteasome/UPS/UPR/bounce-back)
build_carfilzomib <- function(){
  drug <- "Carfilzomib"
  out_csv <- file.path(panels_dir, sprintf("%s_gene_panel.csv", drug))
  gmt_dir <- file.path(panels_dir, sprintf("%s_gmts", drug))
  dir.create(gmt_dir, showWarnings = FALSE, recursive = TRUE)

  PROT_20S_ALPHA <- paste0("PSMA", 1:7)
  PROT_20S_BETA  <- c("PSMB1","PSMB2","PSMB3","PSMB4","PSMB5","PSMB6","PSMB7","PSMB8","PSMB9","PSMB10")
  PROT_19S_BASE  <- c("PSMC1","PSMC2","PSMC3","PSMC4","PSMC5","PSMC6")
  PROT_19S_LID   <- c("PSMD1","PSMD2","PSMD3","PSMD4","PSMD5","PSMD6","PSMD7","PSMD8","PSMD9","PSMD10","PSMD11","PSMD12","PSMD13","PSMD14")
  PROT_ASSEMBLY  <- c("POMP","PSMG1","PSMG2","PSMG3","PSMG4")
  DUBs_CORE      <- c("PSMD14","USP14","UCHL5")
  UBIQUITIN_CORE <- c("UBB","UBA52","RPS27A","UBC","UBA1","UBE2D1","UBE2D2","UBE2D3","UBE2D4","UBE2N","UBE2L3")
  E3_LIGASE_AX   <- c("SKP1","CUL1","CUL3","CUL4A","CUL4B","RBX1","BTRC","FBXW7")
  UPR_ER_STRESS  <- c("ATF4","ATF6","XBP1","HSPA5","EIF2AK3","DDIT3")
  BOUNCE_BACK    <- c("NFE2L1","DDI2","NGLY1")
  APOPTOSIS_EXEC <- c("CASP3","CASP7","CASP8","BAX","BAK1","BCL2","BCL2L1","MCL1","BID","BCL2L11")

  panel <- unique(c(
    PROT_20S_ALPHA, PROT_20S_BETA, PROT_19S_BASE, PROT_19S_LID,
    PROT_ASSEMBLY, DUBs_CORE, UBIQUITIN_CORE, E3_LIGASE_AX,
    UPR_ER_STRESS, BOUNCE_BACK, APOPTOSIS_EXEC
  ))
  tibble(symbol = sort(panel)) %>% write_csv(out_csv)
  message("Wrote panel CSV: ", out_csv)

  write_gmt(list(
    PROTEASOME_20S_ALPHA = PROT_20S_ALPHA,
    PROTEASOME_20S_BETA  = PROT_20S_BETA,
    PROTEASOME_19S_BASE  = PROT_19S_BASE,
    PROTEASOME_19S_LID   = PROT_19S_LID,
    PROTEASOME_ASSEMBLY  = PROT_ASSEMBLY
  ), file.path(gmt_dir, "proteasome_core.symbols.gmt"))

  write_gmt(list(
    UBIQUITIN_CONJUGATION_CORE = UBIQUITIN_CORE,
    E3_LIGASE_AXIS             = E3_LIGASE_AX,
    DEUBIQUITINATION_CORE      = DUBs_CORE
  ), file.path(gmt_dir, "ubiquitin_ups.symbols.gmt"))

  write_gmt(list(
    UPR_ER_STRESS = UPR_ER_STRESS,
    PROTEASOME_BOUNCE_BACK_NRF1_AXIS = BOUNCE_BACK
  ), file.path(gmt_dir, "stress_response.symbols.gmt"))

  write_gmt(list(APOPTOSIS_EXECUTION_MODULE = APOPTOSIS_EXEC),
            file.path(gmt_dir, "apoptosis.symbols.gmt"))
}
build_carfilzomib()

# Docetaxel (taxane; MT/spindle/efflux)
build_docetaxel <- function(){
  drug <- "Docetaxel"
  out_csv <- file.path(panels_dir, sprintf("%s_gene_panel.csv", drug))
  gmt_dir <- file.path(panels_dir, sprintf("%s_gmts", drug))
  dir.create(gmt_dir, showWarnings = FALSE, recursive = TRUE)

  MICROTUBULE_BETA   <- c("TUBB","TUBB2A","TUBB2B","TUBB3","TUBB4B","TUBB6")
  MICROTUBULE_ALPHA  <- c("TUBA1A","TUBA1B","TUBA1C","TUBA3C","TUBA4A")
  MT_ASSOCIATED      <- c("MAP4","MAPT","MAP1B","STMN1")
  KINESINS           <- c("KIF11","KIF2C","KIF5B","KIF20A","KIF15")
  SPINDLE_CHECKPOINT <- c("AURKA","AURKB","PLK1","BUB1","BUB1B","MAD2L1","CDC20","CDK1","CCNB1")
  EFFLUX_RESISTANCE  <- c("ABCB1","ABCC10")
  APOPTOSIS_MITOSIS  <- c("BCL2","BCL2L1","MCL1","BAX","BAK1","CASP3","CASP7","CASP8")

  panel <- unique(c(
    MICROTUBULE_BETA, MICROTUBULE_ALPHA, MT_ASSOCIATED,
    KINESINS, SPINDLE_CHECKPOINT, EFFLUX_RESISTANCE, APOPTOSIS_MITOSIS
  ))
  tibble(symbol = sort(panel)) %>% write_csv(out_csv)
  message("Wrote panel CSV: ", out_csv)

  write_gmt(list(
    MICROTUBULE_CORE_BETA    = MICROTUBULE_BETA,
    MICROTUBULE_CORE_ALPHA   = MICROTUBULE_ALPHA,
    MT_ASSOCIATED_REGULATORS = MT_ASSOCIATED
  ), file.path(gmt_dir, "microtubule_core.symbols.gmt"))

  write_gmt(list(
    KINESIN_MOTOR_SET = KINESINS,
    SPINDLE_ASSEMBLY_CHECKPOINT = SPINDLE_CHECKPOINT
  ), file.path(gmt_dir, "mitotic_machinery.symbols.gmt"))

  write_gmt(list(
    TAXANE_EFFLUX_RESISTANCE       = EFFLUX_RESISTANCE,
    APOPTOSIS_AFTER_MITOTIC_STRESS = APOPTOSIS_MITOSIS
  ), file.path(gmt_dir, "taxane_resistance_apoptosis.symbols.gmt"))
}
build_docetaxel()

# Brigimadlin (MDM2–p53 axis)
build_brigimadlin <- function(){
  drug <- "Brigimadlin"
  out_csv <- file.path(panels_dir, sprintf("%s_gene_panel.csv", drug))
  gmt_dir <- file.path(panels_dir, sprintf("%s_gmts", drug))
  dir.create(gmt_dir, showWarnings = FALSE, recursive = TRUE)

  P53_core_axis <- c("TP53","MDM2","MDM4","CDKN2A","TP53BP1","TP53BP2","PPM1D","USP7","RCHY1","RFWD2","EP300","CREBBP")
  P53_apoptosis_targets <- c("BAX","BAK1","PMAIP1","BBC3","FAS","TNFRSF10B","APAF1","TP53I3","BID","BCL2L11")
  P53_cellcycle_targets <- c("CDKN1A","GADD45A","GADD45B","GADD45G","RRM2B","SESN1","SESN2","SESN3","CCNG1","SFN")
  DNA_damage_signaling  <- c("ATM","ATR","CHEK1","CHEK2","TP53BP1","H2AFX","MRE11A","RAD50","NBN","DDB2","XPC")
  P53_feedback_neg_reg  <- c("MDM2","MDM4","PPM1D","RCHY1","RFWD2","USP7","SIRT1","DAXX","PIAS1")
  BCL2_family_mod       <- c("BCL2","BCL2L1","MCL1","BCL2A1","BCL2L2","BCL2L11","BID","BAX","BAK1")
  MDM2_amp_coblock_12q  <- c("MDM2","CDK4","HMGA2","YEATS4","CPM","TSPAN31","LRIG3","SAS10")
  P53_senescence        <- c("CDKN2A","CDKN2B","TP53INP1","ZMAT3","TIGAR")

  panel <- unique(c(
    P53_core_axis, P53_apoptosis_targets, P53_cellcycle_targets,
    DNA_damage_signaling, P53_feedback_neg_reg, BCL2_family_mod,
    MDM2_amp_coblock_12q, P53_senescence
  ))
  tibble(symbol = sort(panel)) %>% write_csv(out_csv)
  message("Wrote panel CSV: ", out_csv)

  write_gmt(list(
    P53_CORE_AXIS                    = P53_core_axis,
    P53_APOPTOSIS_TARGETS            = P53_apoptosis_targets,
    P53_CELL_CYCLE_ARREST_TARGETS    = P53_cellcycle_targets,
    DNA_DAMAGE_SIGNALING             = DNA_damage_signaling,
    P53_FEEDBACK_NEGATIVE_REGULATORS = P53_feedback_neg_reg
  ), file.path(gmt_dir, "p53_core_and_pathway.symbols.gmt"))

  write_gmt(list(BCL2_FAMILY_APOPTOSIS_MODULATORS = BCL2_family_mod),
            file.path(gmt_dir, "bcl2_family.symbols.gmt"))

  write_gmt(list(P53_SENESCENCE_PROGRAM = P53_senescence),
            file.path(gmt_dir, "p53_senescence.symbols.gmt"))

  write_gmt(list(MDM2_AMP_COAMPLIFIED_12Q13_15 = MDM2_amp_coblock_12q),
            file.path(gmt_dir, "mdm2_amp_coblock_12q.symbols.gmt"))
}
build_brigimadlin()

# Vinca core (shared by Vincristine/Vinblastine)
VINCA_TUBB_BETA   <- c("TUBB","TUBB2A","TUBB2B","TUBB3","TUBB4B","TUBB6")
VINCA_TUBA_ALPHA  <- c("TUBA1A","TUBA1B","TUBA1C","TUBA4A","TUBA3C")
VINCA_MT_ASSOC    <- c("STMN1","MAP4","MAP1B","MAPT")
VINCA_KINESINS    <- c("KIF11","KIF15","KIF20A","KIF2C")         # include depolymerising kinesin-13 family member
VINCA_SPINDLE_CHK <- c("AURKA","AURKB","PLK1","BUB1","BUB1B","MAD2L1","CDC20","CDK1","CCNB1")
VINCA_APOP_MITOS  <- c("BAX","BAK1","CASP3","CASP7","CASP8","BCL2","BCL2L1","MCL1")

# Vincristine (VCR) with emphasis on ABCB1 / STMN1 / TUBB3
build_vincristine <- function(){
  drug <- "Vincristine"
  out_csv <- file.path(panels_dir, sprintf("%s_gene_panel.csv", drug))
  gmt_dir <- file.path(panels_dir, sprintf("%s_gmts", drug))
  dir.create(gmt_dir, showWarnings = FALSE, recursive = TRUE)

  # Efflux: VCR core focus on ABCB1
  VCR_EFFLUX_CORE <- c("ABCB1")
  # Emphasis set (not weighted numerically, but separated so you can GSEA it)
  VCR_EMPHASIS    <- c("ABCB1","STMN1","TUBB3")

  panel <- unique(c(
    VINCA_TUBB_BETA, VINCA_TUBA_ALPHA, VINCA_MT_ASSOC,
    VINCA_KINESINS, VINCA_SPINDLE_CHK, VCR_EFFLUX_CORE, VINCA_APOP_MITOS
  ))
  tibble(symbol = sort(panel)) %>% write_csv(out_csv)
  message("Wrote panel CSV: ", out_csv)

  write_gmt(list(
    VINCA_TUBULIN_BETA      = VINCA_TUBB_BETA,
    VINCA_TUBULIN_ALPHA     = VINCA_TUBA_ALPHA,
    VINCA_MT_ASSOCIATED     = VINCA_MT_ASSOC,
    VINCA_KINESINS          = VINCA_KINESINS,
    VINCA_SPINDLE_CHECKPOINT= VINCA_SPINDLE_CHK,
    VCR_EFFLUX_CORE_ABCB1   = VCR_EFFLUX_CORE,
    VINCA_APOP_MITOTIC      = VINCA_APOP_MITOS,
    VCR_EMPHASIS_ABCB1_STMN1_TUBB3 = VCR_EMPHASIS
  ), file.path(gmt_dir, "vincristine_core.symbols.gmt"))
}
build_vincristine()

# Vinblastine (VBL) with expanded efflux (ABCB1 + ABCC1/ABCC2)
build_vinblastine <- function(){
  drug <- "Vinblastine"
  out_csv <- file.path(panels_dir, sprintf("%s_gene_panel.csv", drug))
  gmt_dir <- file.path(panels_dir, sprintf("%s_gmts", drug))
  dir.create(gmt_dir, showWarnings = FALSE, recursive = TRUE)

  # Efflux: expanded exploratory axis
  VBL_EFFLUX_EXT <- c("ABCB1","ABCC1","ABCC2")

  panel <- unique(c(
    VINCA_TUBB_BETA, VINCA_TUBA_ALPHA, VINCA_MT_ASSOC,
    VINCA_KINESINS, VINCA_SPINDLE_CHK, VBL_EFFLUX_EXT, VINCA_APOP_MITOS
  ))
  tibble(symbol = sort(panel)) %>% write_csv(out_csv)
  message("Wrote panel CSV: ", out_csv)

  write_gmt(list(
    VINCA_TUBULIN_BETA       = VINCA_TUBB_BETA,
    VINCA_TUBULIN_ALPHA      = VINCA_TUBA_ALPHA,
    VINCA_MT_ASSOCIATED      = VINCA_MT_ASSOC,
    VINCA_KINESINS           = VINCA_KINESINS,
    VINCA_SPINDLE_CHECKPOINT = VINCA_SPINDLE_CHK,
    VBL_EFFLUX_EXTENDED      = VBL_EFFLUX_EXT,
    VINCA_APOP_MITOTIC       = VINCA_APOP_MITOS
  ), file.path(gmt_dir, "vinblastine_core.symbols.gmt"))
}
build_vinblastine()

message("All requested panels (including Vincristine/Vinblastine tweaks) rebuilt under 'drug_gene_panels/'.")



# Assumes a DESeq2 object 'dds' is in memory with colData including:
# Batch (optional), Lineage, cell_type, name, and per-drug response columns.

# If needed: dds <- readRDS("Robjects_cell_type/dds.rds")
suppressPackageStartupMessages({
  library(DESeq2); library(dplyr); library(readr); library(tidyr); library(tibble)
  library(AnnotationDbi); library(org.Hs.eg.db); library(stringr)
})

# CONFIG
drugs <- c("Erdafitinib","Fexagratinib","Talazoparib","Obatoclax","Vinblastine","Vincristine")
panels_dir <- "drug_gene_panels"  # where <Drug>_gene_panel.csv and <Drug>_gmts/ live
dir.create("de_by_drug", showWarnings = FALSE, recursive = TRUE)
dir.create("Robjects_by_drug", showWarnings = FALSE, recursive = TRUE)

# HELPERS
sanitize      <- function(x) gsub("[^A-Za-z0-9._-]+","_", x)
sanitize_key  <- function(x) gsub("[^a-z0-9]","", tolower(x))

find_response_col <- function(pheno, drug){
  cn <- colnames(pheno); s_cn <- sanitize_key(cn); key <- sanitize_key(drug)
  hits_idx <- which(
    stringr::str_detect(s_cn, paste0("^", key, "resp"))      |
    stringr::str_detect(s_cn, paste0("^", key, "response"))  |
    stringr::str_detect(s_cn, paste0("^", key, "responder")) |
    s_cn == key | stringr::str_detect(s_cn, paste0("^", key, "_?$"))
  )
  if (length(hits_idx)==0) character(0) else cn[hits_idx]
}

standardize_response <- function(x){
  xl <- tolower(trimws(as.character(x)))
  ifelse(
    xl %in% c("responder","r","yes","y","true","1","resp","responders"),
    "Responder",
    ifelse(xl %in% c("non_responder","nonresponder","nr","no","n","false","0","non-responder","non responders","nonresponders"),
           "Non_Responder", NA_character_)
  )
}

map_to_symbol <- function(ens_or_sym){
  sy <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = ens_or_sym,
                              column = "SYMBOL", keytype = "ENSEMBL",
                              multiVals = "first")
  na_frac <- mean(is.na(sy))
  if (is.finite(na_frac) && na_frac > 0.8) { names(ens_or_sym) <- ens_or_sym; return(ens_or_sym) }
  sy
}

is_full_rank_design <- function(coldata, formula){
  mm <- try(model.matrix(formula, data = as.data.frame(coldata)), silent = TRUE)
  if (inherits(mm, "try-error")) return(FALSE)
  all(is.finite(mm)) && nrow(mm) >= ncol(mm) && qr(mm)$rank == ncol(mm)
}

choose_design <- function(dds_sub){
  cd <- as.data.frame(colData(dds_sub))
  if ("Batch" %in% names(cd)) cd$Batch <- droplevels(factor(cd$Batch))
  cd$group <- droplevels(factor(cd$group))
  if ("Batch" %in% names(cd) && nlevels(cd$Batch) > 1 && is_full_rank_design(cd, ~ Batch + group)) return(~ Batch + group)
  if ( is_full_rank_design(cd, ~ group) ) return(~ group)
  NULL
}

# panel utils
read_gmt <- function(path){
  if (!file.exists(path)) return(list())
  con <- file(path, open = "r"); on.exit(close(con))
  out <- list()
  while (length(line <- readLines(con, n = 1, warn = FALSE)) > 0) {
    parts <- strsplit(line, "\t")[[1]]
    if (length(parts) >= 3) out[[parts[1]]] <- parts[-c(1,2)]
  }
  out
}

# Helper: first matching column name (case-insensitive), else first column
.first_matching_col <- function(df, candidates){
  nms <- names(df)
  hit <- which(tolower(nms) %in% tolower(candidates))
  if (length(hit)) nms[hit[1]] else nms[1]
}

panel_symbols_for_drug <- function(drug, panels_dir){
  # CSV (first usable column among common symbol-like names)
  panel_syms_csv <- character(0)
  panel_csv <- file.path(panels_dir, paste0(drug, "_gene_panel.csv"))
  if (file.exists(panel_csv)) {
    gp <- readr::read_csv(panel_csv, show_col_types = FALSE)
    cands <- c("symbol","SYMBOL","gene","genes","gene_symbol","hgnc","hgnc_symbol")
    sym_col <- .first_matching_col(gp, cands)
    panel_syms_csv <- unique(na.omit(as.character(gp[[sym_col]])))
  }

  # GMT union (concatenate all *.symbols.gmt gene sets)
  gmt_dir <- file.path(panels_dir, paste0(drug, "_gmts"))
  gmt_files <- if (dir.exists(gmt_dir)) list.files(gmt_dir, pattern = "\\.symbols\\.gmt$", full.names = TRUE) else character(0)
  panel_syms_gmt <- if (length(gmt_files)) unique(unlist(lapply(gmt_files, read_gmt), use.names = FALSE)) else character(0)

  # Return upper-cased unique symbols for matching
  unique(toupper(c(panel_syms_csv, panel_syms_gmt)))
}

run_de_and_save <- function(dds_sub, out_dir, sym_map,
                            label_prefix = "", save_rds_basename = NULL,
                            panel_syms = character(0)){
  # Clean factors
  if ("Batch" %in% colnames(colData(dds_sub)))
    colData(dds_sub)$Batch <- droplevels(factor(colData(dds_sub)$Batch))
  colData(dds_sub)$group <- droplevels(factor(colData(dds_sub)$group, levels = c("Non_Responder","Responder")))

  des <- choose_design(dds_sub)
  if (is.null(des)) {
    warning("Design not identifiable for subset '", label_prefix, "' (likely only one class). Skipping.")
    return(list(design = NA_character_, n_sig = NA_integer_, n_panel_all = NA_integer_, n_panel_sig = NA_integer_))
  }
  design(dds_sub) <- des

  de_fit <- DESeq(dds_sub, quiet = TRUE)
  res <- results(de_fit, contrast = c("group","Responder","Non_Responder"), alpha = 0.05)

  res_df <- as.data.frame(res) %>%
    tibble::rownames_to_column("gene_id") %>%
    dplyr::mutate(symbol = unname(sym_map[gene_id])) %>%
    tibble::as_tibble()

  dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

  all_nona <- res_df %>% tidyr::drop_na(padj) %>% dplyr::arrange(padj)
  readr::write_csv(all_nona, file.path(out_dir, paste0(label_prefix, "ALL.csv")))

  sig_nona <- all_nona %>% dplyr::filter(padj < 0.05)
  readr::write_csv(sig_nona, file.path(out_dir, paste0(label_prefix, "SIG_padj_lt_0.05.csv")))

  # Panel-filtered outputs
  panel_all <- panel_sig <- NULL
  if (length(panel_syms) > 0) {
    panel_all <- all_nona %>%
      dplyr::mutate(SYMBOL_UPPER = toupper(symbol), GENE_UPPER = toupper(gene_id)) %>%
      dplyr::filter(SYMBOL_UPPER %in% panel_syms | GENE_UPPER %in% panel_syms) %>%
      dplyr::select(-SYMBOL_UPPER, -GENE_UPPER)
    readr::write_csv(panel_all, file.path(out_dir, paste0(label_prefix, "PANEL_ALL.csv")))

    panel_sig <- sig_nona %>%
      dplyr::mutate(SYMBOL_UPPER = toupper(symbol), GENE_UPPER = toupper(gene_id)) %>%
      dplyr::filter(SYMBOL_UPPER %in% panel_syms | GENE_UPPER %in% panel_syms) %>%
      dplyr::select(-SYMBOL_UPPER, -GENE_UPPER)
    readr::write_csv(panel_sig, file.path(out_dir, paste0(label_prefix, "PANEL_SIG_padj_lt_0.05.csv")))
  }

  if (!is.null(save_rds_basename)) {
    saveRDS(de_fit, file = file.path("Robjects_by_drug", paste0(save_rds_basename, ".rds")))
  }

  list(
    design = deparse(stats::formula(des)),
    n_sig = nrow(sig_nona),
    n_panel_all = if (!is.null(panel_all)) nrow(panel_all) else NA_integer_,
    n_panel_sig = if (!is.null(panel_sig)) nrow(panel_sig) else NA_integer_
  )
}

# symbol map
ens_ids <- rownames(dds)
sym_map <- map_to_symbol(ens_ids)

# MAIN LOOP
pheno <- as.data.frame(colData(dds))
stopifnot(all(c("cell_type","Lineage") %in% colnames(pheno)))

sum_overall        <- list()
sum_ct_within_lin  <- list()
sum_ct_global      <- list()

for (drug in drugs) {
  message("\n=== ", drug, " ===")
  resp_candidates <- find_response_col(pheno, drug)
  if (length(resp_candidates) == 0) { warning("No response column found for ", drug, ". Skipping."); next }
  resp_col <- resp_candidates[1]
  resp_std <- standardize_response(pheno[[resp_col]])

  # load panel symbols for this drug (uppercase)
  panel_syms <- panel_symbols_for_drug(drug, panels_dir)

  # OVERALL
  keep_overall <- !is.na(resp_std) & resp_std %in% c("Responder","Non_Responder")
  if (sum(keep_overall) >= 2 && all(c("Responder","Non_Responder") %in% unique(resp_std[keep_overall]))) {
    dds_overall <- dds[, keep_overall]
    colData(dds_overall)$group <- factor(resp_std[keep_overall], levels = c("Non_Responder","Responder"))

    out_dir_overall <- file.path("de_by_drug", drug)
    res_overall <- run_de_and_save(
      dds_sub = dds_overall,
      out_dir = out_dir_overall,
      sym_map = sym_map,
      label_prefix = paste0(drug, "_Responder_vs_NonResponder_"),
      save_rds_basename = paste0("dds_", drug, "_Responder_vs_NonResponders_allLineages"),
      panel_syms = panel_syms
    )

    tab_overall <- table(colData(dds_overall)$group)
    sum_overall[[drug]] <- tibble(
      drug = drug, scope = "overall", lineage = NA_character_, responder_cell_type = NA_character_,
      response_column = resp_col, n_samples = ncol(dds_overall),
      n_responder = unname(tab_overall["Responder"]), n_non_responder = unname(tab_overall["Non_Responder"]),
      design = res_overall$design, n_DE_padj_lt_0_05 = res_overall$n_sig,
      n_DE_panel_ALL = res_overall$n_panel_all, n_DE_panel_SIG = res_overall$n_panel_sig
    )
  }

  # WITHIN-LINEAGE
  lin_vec  <- as.character(pheno$Lineage)
  ct_vec   <- as.character(pheno$cell_type)

  for (lin in unique(na.omit(lin_vec))) {
    idx_lin <- which(lin_vec == lin & !is.na(resp_std) & resp_std %in% c("Responder","Non_Responder"))
    if (length(idx_lin) == 0) next

    df_lin <- tibble(idx = idx_lin, cell_type = ct_vec[idx_lin], resp = resp_std[idx_lin])

    ct_status <- df_lin %>%
      group_by(cell_type) %>%
      summarize(n = n(),
                n_status = n_distinct(resp),
                status = ifelse(n_status == 1, first(resp), NA_character_),
                .groups = "drop")

    resp_cts <- ct_status %>% filter(status == "Responder") %>% pull(cell_type)
    nonr_cts <- ct_status %>% filter(status == "Non_Responder") %>% pull(cell_type)
    if (length(resp_cts) == 0 || length(nonr_cts) == 0) next

    for (ctR in resp_cts) {
      idx <- which(lin_vec == lin & ct_vec %in% c(ctR, nonr_cts) &
                     !is.na(resp_std) & resp_std %in% c("Responder","Non_Responder"))
      if (length(idx) < 2) next

      dds_ct <- dds[, idx]
      grp <- ifelse(ct_vec[idx] == ctR, "Responder", "Non_Responder")
      colData(dds_ct)$group <- factor(grp, levels = c("Non_Responder","Responder"))

      out_dir_ct <- file.path("de_by_drug", drug, "by_lineage_celltype", sanitize(lin), sanitize(ctR))
      label_prefix <- paste0(drug, "_", sanitize(lin), "_", sanitize(ctR), "_Responder_vs_NonResponders_")

      res_ct <- run_de_and_save(
        dds_sub = dds_ct,
        out_dir = out_dir_ct,
        sym_map = sym_map,
        label_prefix = label_prefix,
        save_rds_basename = paste0("dds_", drug, "_", sanitize(lin), "_", sanitize(ctR), "_vs_NonResponders_withinLineage"),
        panel_syms = panel_syms
      )

      tab_ct <- table(colData(dds_ct)$group)
      sum_ct_within_lin[[paste(drug, lin, ctR, sep="|")]] <- tibble(
        drug = drug, scope = "by_lineage_celltype",
        lineage = lin, responder_cell_type = ctR,
        response_column = resp_col,
        n_samples = ncol(dds_ct),
        n_responder_samples = unname(tab_ct["Responder"]),
        n_non_responder_samples = unname(tab_ct["Non_Responder"]),
        design = res_ct$design,
        n_DE_padj_lt_0_05 = res_ct$n_sig,
        n_DE_panel_ALL = res_ct$n_panel_all,
        n_DE_panel_SIG = res_ct$n_panel_sig
      )
    }
  }

  # GLOBAL per-cell-type (e.g., MFS1) vs ALL Non-Responders (ignoring lineage)
  valid_idx <- which(!is.na(resp_std) & resp_std %in% c("Responder","Non_Responder"))
  if (length(valid_idx) >= 2) {
    df_global <- tibble(cell_type = ct_vec[valid_idx], resp = resp_std[valid_idx])
    ct_status_global <- df_global %>%
      group_by(cell_type) %>%
      summarize(n = n(), n_status = n_distinct(resp),
                status = ifelse(n_status == 1, first(resp), NA_character_), .groups = "drop")

    resp_cts_global <- ct_status_global %>% filter(status == "Responder") %>% pull(cell_type)
    nonr_cts_global <- ct_status_global %>% filter(status == "Non_Responder") %>% pull(cell_type)

    if (length(resp_cts_global) > 0 && length(nonr_cts_global) > 0) {
      for (ctR in resp_cts_global) {
        idx <- which(ct_vec %in% c(ctR, nonr_cts_global) &
                       !is.na(resp_std) & resp_std %in% c("Responder","Non_Responder"))
        if (length(idx) < 3) next  # need enough samples

        dds_ct_glob <- dds[, idx]
        grp <- ifelse(ct_vec[idx] == ctR, "Responder", "Non_Responder")
        colData(dds_ct_glob)$group <- factor(grp, levels = c("Non_Responder","Responder"))

        out_dir_glob <- file.path("de_by_drug", drug, "by_celltype_global", sanitize(ctR))
        label_prefix <- paste0(drug, "_GLOBAL_", sanitize(ctR), "_Responder_vs_ALL_NonResponders_")

        res_glob <- run_de_and_save(
          dds_sub = dds_ct_glob,
          out_dir = out_dir_glob,
          sym_map = sym_map,
          label_prefix = label_prefix,
          save_rds_basename = paste0("dds_", drug, "_GLOBAL_", sanitize(ctR), "_vs_ALL_NonResponders"),
          panel_syms = panel_syms   # PANEL FILTERING INCLUDED HERE
        )

        tab_g <- table(colData(dds_ct_glob)$group)
        sum_ct_global[[paste(drug, ctR, sep="|")]] <- tibble(
          drug = drug, scope = "by_celltype_global",
          lineage = NA_character_, responder_cell_type = ctR,
          response_column = resp_col,
          n_samples = ncol(dds_ct_glob),
          n_responder_samples = unname(tab_g["Responder"]),
          n_non_responder_samples = unname(tab_g["Non_Responder"]),
          design = res_glob$design,
          n_DE_padj_lt_0_05 = res_glob$n_sig,
          n_DE_panel_ALL = res_glob$n_panel_all,
          n_DE_panel_SIG = res_glob$n_panel_sig
        )
      }
    }
  }
}

# SUMMARIES
if (length(sum_overall)) {
  bind_rows(sum_overall) %>%
    arrange(drug, desc(n_DE_padj_lt_0_05)) %>%
    write_csv(file.path("de_by_drug", "DE_summary_overall_by_drug.csv"))
}
if (length(sum_ct_within_lin)) {
  bind_rows(sum_ct_within_lin) %>%
    arrange(drug, lineage, responder_cell_type, desc(n_DE_padj_lt_0_05)) %>%
    write_csv(file.path("de_by_drug", "DE_summary_by_drug_lineage_celltype.csv"))
}
if (length(sum_ct_global)) {
  bind_rows(sum_ct_global) %>%
    arrange(drug, responder_cell_type, desc(n_DE_padj_lt_0_05)) %>%
    write_csv(file.path("de_by_drug", "DE_summary_by_drug_celltype_GLOBAL.csv"))
}

message("Done. PANEL_* files are now saved for overall, within-lineage, and GLOBAL per-cell-type analyses.")



```



#clusterProfiler gseGO enrichment (GSEA-style) with dotplots, emapplots, cnetplots
```{r}

# clusterProfiler GSEA: gseGO + MSigDB Reactome & Hallmark
#      (dotplot / emapplot / cnetplot / gseaplot2)

suppressPackageStartupMessages({
  library(dplyr); library(readr); library(tidyr); library(tibble)
  library(stringr); library(ggplot2)
  library(clusterProfiler); library(enrichplot)
  library(msigdbr)
  library(AnnotationDbi); library(org.Hs.eg.db)
})

# config
de_root   <- "de_by_drug"               # where your DE *_ALL.csv live
out_root  <- "enrichment_by_drug_cp"    # output root for clusterProfiler GSEA
dir.create(out_root, showWarnings = FALSE, recursive = TRUE)

go_ontologies   <- c("BP","MF")         # add "CC" if desired

# GSEA settings (full-universe)
minGS_go        <- 10                   # gseGO min size (full)
minGS_sets      <- 10                   # Reactome/Hallmark min size (full)
maxGSSize       <- 500
pAdjustMethod   <- "BH"
pvalueCutoff_all <- 1                   # << relaxed: keep all terms to inspect
eps_break_ties  <- TRUE                 # tiny jitter to break exact ties in ranks
set.seed(42)

# Panel-restricted settings (allow smaller sets)
panel_minGS_go    <- 2
panel_minGS_sets  <- 2
pvalueCutoff_pan  <- 1                  # << relaxed for panel runs too

# Filenames kept short/safe
max_slug_chars <- 80
safe_slug <- function(x, max_n = 80) {
  s <- gsub("[^A-Za-z0-9._-]+", "_", x)
  s <- gsub("^_+|_+$", "", s)
  if (nchar(s) <= max_n) return(s)
  if (requireNamespace("digest", quietly = TRUE)) {
    paste0(substr(s, 1, max_n - 9), "_", substr(digest::digest(s), 1, 8))
  } else substr(s, 1, max_n)
}

# Helpers
# Build ENTREZID-named ranking vector from *_ALL.csv
make_geneList <- function(path_csv) {
  df <- readr::read_csv(path_csv, show_col_types = FALSE)

  # find symbol column or map from Ensembl
  sym_col <- if ("symbol" %in% names(df)) "symbol" else if ("SYMBOL" %in% names(df)) "SYMBOL" else NULL
  if (is.null(sym_col)) {
    if (!"gene_id" %in% names(df)) stop("No 'symbol' or 'gene_id' in: ", path_csv)
    sy <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = df$gene_id,
                                column = "SYMBOL", keytype = "ENSEMBL", multiVals = "first")
    df$symbol <- unname(sy); sym_col <- "symbol"
  }

  # Ranking score preference: stat > signed -log10(p) > log2FC
  if ("stat" %in% names(df) && all(!is.na(df$stat))) {
    score <- df$stat
  } else if (all(c("log2FoldChange","pvalue") %in% names(df))) {
    pv <- pmax(df$pvalue, .Machine$double.xmin)
    score <- sign(df$log2FoldChange) * -log10(pv)
  } else if ("log2FoldChange" %in% names(df)) {
    score <- df$log2FoldChange
  } else stop("Cannot build ranking for: ", path_csv)

  ranks_sym <- tibble(symbol = df[[sym_col]], score = score) %>%
    filter(!is.na(symbol), !is.na(score)) %>%
    group_by(symbol) %>% summarise(score = score[which.max(abs(score))], .groups = "drop")

  ent <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = ranks_sym$symbol,
                               column = "ENTREZID", keytype = "SYMBOL", multiVals = "first")
  geneList <- ranks_sym$score; names(geneList) <- unname(ent)
  gl <- tibble(ENTREZID = names(geneList), score = geneList) %>%
    filter(!is.na(ENTREZID)) %>%
    group_by(ENTREZID) %>% summarise(score = score[which.max(abs(score))], .groups = "drop") %>%
    arrange(desc(score)) %>% { setNames(.$score, .$ENTREZID) }

  if (eps_break_ties) gl <- gl + rnorm(length(gl), sd = 1e-8)
  sort(gl, decreasing = TRUE)
}

# sigdbr helper (robust across versions; no hard stop)
make_termsets <- function(collection, subcollection = NULL, tag) {
  # Try new API first; fallback to old if needed
  df <- try(msigdbr::msigdbr(species = "Homo sapiens",
                             collection = collection, subcollection = subcollection),
            silent = TRUE)
  if (inherits(df, "try-error")) {
    df <- try(msigdbr::msigdbr(species = "Homo sapiens",
                               category = collection, subcategory = subcollection),
              silent = TRUE)
  }
  if (inherits(df, "try-error") || is.null(df) || nrow(df) == 0) {
    warning("msigdbr missing/empty for ", tag, " (", collection, " / ", subcollection, ").")
    return(list(
      TERM2GENE = data.frame(term = character(), gene = character()),
      TERM2NAME = data.frame(term = character(), name = character())
    ))
  }

  # robust column selection
  gs_col <- if ("gs_name" %in% names(df)) "gs_name" else {
    cand <- names(df)[grepl("gs.?name", names(df), ignore.case = TRUE)]
    if (length(cand)) cand[1] else NA_character_
  }
  id_col <- if ("entrez_gene" %in% names(df)) "entrez_gene" else {
    cand <- names(df)[grepl("entrez", names(df), ignore.case = TRUE)]
    if (length(cand)) cand[1] else NA_character_
  }
  desc_col <- if ("gs_description" %in% names(df)) "gs_description" else NA_character_

  if (is.na(gs_col) || is.na(id_col)) {
    warning("msigdbr columns not found for ", tag, ". Available: ", paste(names(df), collapse = ", "))
    return(list(
      TERM2GENE = data.frame(term = character(), gene = character()),
      TERM2NAME = data.frame(term = character(), name = character())
    ))
  }

  t2g <- df %>%
    dplyr::select(all_of(gs_col), all_of(id_col)) %>%
    dplyr::distinct() %>%
    dplyr::filter(!is.na(.data[[id_col]])) %>%
    dplyr::rename(term = !!gs_col, gene = !!id_col) %>%
    as.data.frame()

  t2n <- if (!is.na(desc_col) && desc_col %in% names(df)) {
    df %>%
      dplyr::select(all_of(gs_col), all_of(desc_col)) %>%
      dplyr::distinct() %>%
      dplyr::rename(term = !!gs_col, name = !!desc_col) %>%
      as.data.frame()
  } else {
    data.frame(term = unique(df[[gs_col]]), name = unique(df[[gs_col]]), stringsAsFactors = FALSE)
  }

  list(TERM2GENE = t2g, TERM2NAME = t2n)
}

# Robust panel → ENTREZ mapping
guess_id_type <- function(x) {
  x <- na.omit(trimws(as.character(x)))
  if (!length(x)) return("UNKNOWN")
  if (mean(grepl("^ENSG\\d+", x)) > 0.6) return("ENSEMBL")
  if (mean(grepl("^\\d+$", x))   > 0.6) return("ENTREZ")
  "SYMBOL_OR_ALIAS"
}

map_to_entrez <- function(vec) {
  vec <- unique(na.omit(trimws(as.character(vec))))
  if (!length(vec)) return(character(0))
  idt <- guess_id_type(vec)

  if (idt == "ENTREZ") {
    return(unique(vec))
  } else if (idt == "ENSEMBL") {
    ent <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = vec,
                                 column = "ENTREZID", keytype = "ENSEMBL",
                                 multiVals = "first")
    return(unique(na.omit(unname(ent))))
  } else {
    ent1 <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = vec,
                                  column = "ENTREZID", keytype = "SYMBOL",
                                  multiVals = "first")
    miss <- is.na(ent1)
    if (any(miss)) {
      ent2 <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = vec[miss],
                                    column = "ENTREZID", keytype = "ALIAS",
                                    multiVals = "first")
      ent1[miss] <- ent2
    }
    return(unique(na.omit(unname(ent1))))
  }
}

panel_csv_to_entrez <- function(panel_csv) {
  if (!file.exists(panel_csv)) return(character(0))
  df <- readr::read_csv(panel_csv, show_col_types = FALSE)
  if (!nrow(df)) return(character(0))

  candidate_cols <- c("symbol","SYMBOL","gene","genes","gene_symbol","hgnc","hgnc_symbol",
                      "Gene","GeneSymbol","HGNC","HGNC_symbol","gene_id","ENSEMBL","ensembl",
                      "entrez","ENTREZID")
  use_col <- candidate_cols[candidate_cols %in% names(df)][1]
  if (is.na(use_col) || length(use_col) == 0) use_col <- names(df)[1]

  map_to_entrez(df[[use_col]])
}

# Restrict ENTREZ geneList by *_PANEL_ALL.csv contents (robust), with summary
restrict_geneList_by_panel <- function(geneList, panel_csv, out_dir = NULL, label_panel = NULL) {
  entrez_panel <- panel_csv_to_entrez(panel_csv)
  gl <- geneList[names(geneList) %in% entrez_panel]

  if (!is.null(out_dir) && !is.null(label_panel)) {
    dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
    txt <- file.path(out_dir, paste0(label_panel, "_panel_mapping_summary.txt"))
    cat(paste0(
      "Panel mapping summary for ", label_panel, "\n",
      "panel_csv: ", panel_csv, "\n",
      "n_geneList (full)       = ", length(geneList), "\n",
      "n_panel_ENTREZ_mapped   = ", length(entrez_panel), "\n",
      "n_geneList_after_panel  = ", length(gl), "\n"
    ), file = txt)
  }
  sort(gl, decreasing = TRUE)
}

# robust saver (fixes cnetplot foldChange mismatch & zero-size plots)
save_cp_outputs <- function(gse, geneList, out_dir, label, tag,
                            top_dot = 20, top_emap = 30, top_cnet = 10, top_gsea = 3) {
  dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
  dir.create(file.path(out_dir, "plots"), showWarnings = FALSE, recursive = TRUE)

  # Quick exit if no results
  if (is.null(gse) || nrow(as.data.frame(gse)) == 0) {
    readr::write_csv(tibble(), file.path(out_dir, paste0(label, "_GSEA_", tag, "_none.csv")))
    return(invisible(NULL))
  }

  # Safe ggsave wrapper
  safe_ggsave <- function(path, plot, width, height, dpi = 150) {
    tryCatch(
      { ggplot2::ggsave(path, plot = plot, width = width, height = height, dpi = dpi) },
      error = function(e) message("Skipping save for ", basename(path), ": ", e$message)
    )
  }

  # Keep raw (ENTREZ) and readable (SYMBOL) versions
  gse_raw  <- gse
  gse_read <- tryCatch(clusterProfiler::setReadable(gse, OrgDb = org.Hs.eg.db, keyType = "ENTREZID"),
                       error = function(e) gse_raw)

  # Results table (prefer readable)
  res_df <- as.data.frame(gse_read) %>% dplyr::arrange(p.adjust, dplyr::desc(NES))
  if (nrow(res_df) == 0) {
    readr::write_csv(tibble(), file.path(out_dir, paste0(label, "_GSEA_", tag, "_none.csv")))
    return(invisible(NULL))
  }
  readr::write_csv(res_df, file.path(out_dir, paste0(label, "_GSEA_", tag, "_results.csv")))

  # Dotplot
  n_dot <- min(top_dot, nrow(res_df))
  if (n_dot >= 1) {
    dp <- tryCatch(
      enrichplot::dotplot(gse_read, showCategory = n_dot) +
        ggtitle(paste0("GSEA (", tag, ") — ", label)),
      error = function(e) NULL
    )
    if (!is.null(dp)) {
      safe_ggsave(file.path(out_dir, "plots", paste0(label, "_GSEA_", tag, "_dotplot.png")),
                  dp, width = 10, height = 8)
    }
  }

  # Enrichment map (needs >=2 categories)
  if (requireNamespace("igraph", quietly = TRUE) &&
      requireNamespace("ggraph", quietly = TRUE) &&
      nrow(res_df) >= 2) {
    gse_sim <- tryCatch(enrichplot::pairwise_termsim(gse_read), error = function(e) NULL)
    if (!is.null(gse_sim)) {
      ep <- tryCatch(
        enrichplot::emapplot(gse_sim, showCategory = min(top_emap, nrow(res_df)), layout = "kk") +
          ggtitle(paste0("emapplot GSEA (", tag, ") — ", label)),
        error = function(e) NULL
      )
      if (!is.null(ep)) {
        safe_ggsave(file.path(out_dir, "plots", paste0(label, "_GSEA_", tag, "_emap.png")),
                    ep, width = 10, height = 15)
      }
    }
  }

  # cnetplot
  # Build SYMBOL-named foldChange for readable object
  fc_sym <- tryCatch({
    sy <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = names(geneList),
                                column = "SYMBOL", keytype = "ENTREZID", multiVals = "first")
    stats::setNames(unname(geneList), sy) |> na.omit()
  }, error = function(e) numeric(0))

  # Try readable (SYMBOL) first; fallback to raw (ENTREZ) if needed
  cn <- tryCatch(
    enrichplot::cnetplot(gse_read, showCategory = min(top_cnet, nrow(res_df)),
                         foldChange = fc_sym, circular = FALSE),
    error = function(e) NULL
  )
  if (is.null(cn)) {
    cn <- tryCatch(
      enrichplot::cnetplot(gse_raw, showCategory = min(top_cnet, nrow(as.data.frame(gse_raw))),
                           foldChange = geneList, circular = FALSE),
      error = function(e) NULL
    )
  }
  if (!is.null(cn)) {
    safe_ggsave(file.path(out_dir, "plots", paste0(label, "_GSEA_", tag, "_cnet.png")),
                cn, width = 12, height = 12)
  }

  # gseaplot2 for top up/down by NES
  res_tbl  <- as.data.frame(gse_read)
  top_up   <- res_tbl %>% dplyr::filter(NES > 0) %>% dplyr::arrange(dplyr::desc(NES)) %>% dplyr::pull(ID) %>% head(3)
  top_down <- res_tbl %>% dplyr::filter(NES < 0) %>% dplyr::arrange(NES)               %>% dplyr::pull(ID) %>% head(3)

  plot_one <- function(id, dir_tag) {
    gp <- tryCatch(enrichplot::gseaplot2(gse_read, geneSetID = id, title = paste0(id, " (", dir_tag, ")")),
                   error = function(e) NULL)
    if (!is.null(gp)) {
      fn <- paste0(label, "_GSEA_", tag, "_", safe_slug(id, max_slug_chars), "_", dir_tag, ".png")
      safe_ggsave(file.path(out_dir, "plots", fn), gp, width = 10, height = 10)
    }
  }
  if (length(top_up))   for (id in top_up)   plot_one(id, "UP")
  if (length(top_down)) for (id in top_down) plot_one(id, "DOWN")
}

# term sets (Reactome & Hallmark)
reactome_sets <- make_termsets(collection = "C2", subcollection = "CP:REACTOME", tag = "REACTOME")
hallmark_sets <- make_termsets(collection = "H",  subcollection = NULL,          tag = "HALLMARK")

# ----------------------- scan & run -----------------------
all_de_files <- list.files(de_root, pattern = "_ALL\\.csv$", recursive = TRUE, full.names = TRUE)
if (length(all_de_files) == 0) stop("No DE files found under '", de_root, "' (expected '*_ALL.csv').")

for (csv_path in all_de_files) {
  rel     <- stringr::str_replace(csv_path, paste0("^", de_root), "")
  rel_dir <- dirname(rel)
  out_dir <- file.path(out_root, rel_dir)
  dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

  label <- tools::file_path_sans_ext(basename(csv_path))

  # Build full geneList (ENTREZID-named, decreasing)
  geneList <- tryCatch(make_geneList(csv_path),
                       error = function(e) { message("Skipping GSEA for ", csv_path, ": ", e$message); NULL })
  if (is.null(geneList) || length(geneList) < min(minGS_go, minGS_sets)) {
    readr::write_csv(tibble(), file.path(out_dir, paste0(label, "_GSEA_none.csv")))
    next
  }

  # gseGO (full-universe; relaxed pvalueCutoff)
  for (ont in go_ontologies) {
    gse_go <- tryCatch(
      clusterProfiler::gseGO(
        geneList      = geneList,
        OrgDb         = org.Hs.eg.db,
        keyType       = "ENTREZID",
        ont           = ont,
        minGSSize     = minGS_go,
        maxGSSize     = maxGSSize,
        pAdjustMethod = pAdjustMethod,
        pvalueCutoff  = pvalueCutoff_all,   # << relaxed
        verbose       = FALSE
      ),
      error = function(e) NULL
    )
    save_cp_outputs(gse_go, geneList, out_dir, label, paste0("GO_", ont))
  }

  # Reactome (MSigDB; relaxed pvalueCutoff)
  if (nrow(reactome_sets$TERM2GENE) > 0) {
    gse_re <- tryCatch(
      clusterProfiler::GSEA(
        geneList      = geneList,
        TERM2GENE     = reactome_sets$TERM2GENE,
        TERM2NAME     = reactome_sets$TERM2NAME,
        minGSSize     = minGS_sets,
        maxGSSize     = maxGSSize,
        pAdjustMethod = pAdjustMethod,
        pvalueCutoff  = pvalueCutoff_all,   # << relaxed
        verbose       = FALSE,
        seed          = TRUE
      ),
      error = function(e) NULL
    )
    save_cp_outputs(gse_re, geneList, out_dir, label, "REACTOME")
  } else {
    readr::write_csv(tibble(), file.path(out_dir, paste0(label, "_GSEA_REACTOME_none.csv")))
  }

  # Hallmark (MSigDB; relaxed pvalueCutoff)
  if (nrow(hallmark_sets$TERM2GENE) > 0) {
    gse_h <- tryCatch(
      clusterProfiler::GSEA(
        geneList      = geneList,
        TERM2GENE     = hallmark_sets$TERM2GENE,
        TERM2NAME     = hallmark_sets$TERM2NAME,
        minGSSize     = minGS_sets,
        maxGSSize     = maxGSSize,
        pAdjustMethod = pAdjustMethod,
        pvalueCutoff  = pvalueCutoff_all,   # << relaxed
        verbose       = FALSE,
        seed          = TRUE
      ),
      error = function(e) NULL
    )
    save_cp_outputs(gse_h, geneList, out_dir, label, "HALLMARK")
  } else {
    readr::write_csv(tibble(), file.path(out_dir, paste0(label, "_GSEA_HALLMARK_none.csv")))
  }

  # Panel-restricted variants (robust mapping; relaxed pvalueCutoff)
  panel_all_csv <- sub("_ALL\\.csv$", "_PANEL_ALL.csv", csv_path)
  if (file.exists(panel_all_csv)) {
    label_panel    <- paste0(label, "_PANEL")
    geneList_panel <- restrict_geneList_by_panel(geneList, panel_all_csv,
                                                 out_dir = out_dir, label_panel = label_panel)

    panel_minGS_go_eff   <- max(2, panel_minGS_go)
    panel_minGS_sets_eff <- max(2, panel_minGS_sets)

    if (length(geneList_panel) >= min(panel_minGS_go_eff, panel_minGS_sets_eff)) {

      # gseGO (panel)
      for (ont in go_ontologies) {
        gse_go_p <- tryCatch(
          clusterProfiler::gseGO(
            geneList      = geneList_panel,
            OrgDb         = org.Hs.eg.db,
            keyType       = "ENTREZID",
            ont           = ont,
            minGSSize     = panel_minGS_go_eff,
            maxGSSize     = maxGSSize,
            pAdjustMethod = pAdjustMethod,
            pvalueCutoff  = pvalueCutoff_pan,   # << relaxed
            verbose       = FALSE
          ),
          error = function(e) NULL
        )
        save_cp_outputs(gse_go_p, geneList_panel, out_dir, label_panel, paste0("GO_", ont))
      }

      # Reactome (panel)
      if (nrow(reactome_sets$TERM2GENE) > 0) {
        gse_re_p <- tryCatch(
          clusterProfiler::GSEA(
            geneList      = geneList_panel,
            TERM2GENE     = reactome_sets$TERM2GENE,
            TERM2NAME     = reactome_sets$TERM2NAME,
            minGSSize     = panel_minGS_sets_eff,
            maxGSSize     = maxGSSize,
            pAdjustMethod = pAdjustMethod,
            pvalueCutoff  = pvalueCutoff_pan,   # << relaxed
            verbose       = FALSE,
            seed          = TRUE
          ),
          error = function(e) NULL
        )
        save_cp_outputs(gse_re_p, geneList_panel, out_dir, label_panel, "REACTOME")
      }

      # Hallmark (panel)
      if (nrow(hallmark_sets$TERM2GENE) > 0) {
        gse_h_p <- tryCatch(
          clusterProfiler::GSEA(
            geneList      = geneList_panel,
            TERM2GENE     = hallmark_sets$TERM2GENE,
            TERM2NAME     = hallmark_sets$TERM2NAME,
            minGSSize     = panel_minGS_sets_eff,
            maxGSSize     = maxGSSize,
            pAdjustMethod = pAdjustMethod,
            pvalueCutoff  = pvalueCutoff_pan,   # << relaxed
            verbose       = FALSE,
            seed          = TRUE
          ),
          error = function(e) NULL
        )
        save_cp_outputs(gse_h_p, geneList_panel, out_dir, label_panel, "HALLMARK")
      }

    } else {
      readr::write_csv(tibble(), file.path(out_dir, paste0(label_panel, "_GSEA_panel_none.csv")))
    }
  }
}

message("Done. clusterProfiler GSEA (GO/Reactome/Hallmark; full + PANEL) saved under '", out_root, "'.")


```

