---
title: "Mim's RNSseq STAR_RSEM ENSEMBL priming and gene expression correlations with Talazoparib drug sensitivities from qHTS results"
output: html_document
editor_options: 
  chunk_output_type: inline
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.


```{r}
# Minimal pipeline: VST → PARPi biomarkers (core) → Talazoparib correlations
suppressPackageStartupMessages({
  library(DESeq2); library(readr); library(dplyr); library(tidyr)
  library(AnnotationDbi); library(org.Hs.eg.db)
  library(ggplot2); library(ggrepel)
  library(limma)     # removeBatchEffect
  library(purrr)     # map_dfr
  library(cowplot)   # side stamp composition
})

# INPUTS
counts_tsv     <- "left_merged_STS_Batches_1_2_gene_counts.tsv"
sampleinfo_csv <- "sampleinfo_STS_DrugSens_2025.csv"   # name, Batch, cell_type, (optional) Lineage
tzb_csv        <- "talazoparib_metrics.csv"            # cell_line, IC50_nM, AUC (AUC: 1=death, 0=viability)
out_root       <- file.path(getwd(), "talazoparib_results"); dir.create(out_root, FALSE, TRUE)

# Load counts + sample metadata
sampleinfo <- readr::read_csv(sampleinfo_csv, show_col_types = FALSE)
stopifnot(all(c("name","Batch","cell_type") %in% names(sampleinfo)))

rsem_counts <- readr::read_tsv(counts_tsv, show_col_types = FALSE)
gene_ids    <- rsem_counts$gene_id
cnt_mat     <- rsem_counts |> dplyr::select(-1, -2) |> as.data.frame() |> as.matrix()
rownames(cnt_mat) <- gene_ids

# keep only samples present in sampleinfo$name (order must match)
stopifnot(all(colnames(cnt_mat) %in% sampleinfo$name))
sampleinfo <- sampleinfo[match(colnames(cnt_mat), sampleinfo$name), , drop = FALSE]
stopifnot(all(colnames(cnt_mat) == sampleinfo$name))

# quick filter: ≥10 counts in ≥4 samples
keep <- rowSums(cnt_mat >= 10) >= 4
cnt_mat <- cnt_mat[keep, , drop = FALSE]

#  Map to SYMBOLs and collapse duplicates
sym_map <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = rownames(cnt_mat),
                                 column = "SYMBOL", keytype = "ENSEMBL", multiVals = "first")
cnt_sym <- cnt_mat[!is.na(sym_map), , drop = FALSE]
rownames(cnt_sym) <- sym_map[!is.na(sym_map)]
cnt_sym <- rowsum(cnt_sym, group = rownames(cnt_sym))

# DESeq2 object and VST (blind=FALSE)
sampleinfo$Batch     <- droplevels(factor(sampleinfo$Batch))
sampleinfo$cell_type <- droplevels(factor(sampleinfo$cell_type))

dds <- DESeqDataSetFromMatrix(countData = round(cnt_sym),
                              colData   = sampleinfo,
                              design    = ~ Batch + cell_type)
vsd <- vst(dds, blind = FALSE)
vst_mat <- assay(vsd)

# remove batch for downstream correlations (viz/metrics only)
vst_bc <- limma::removeBatchEffect(
  vst_mat,
  batch  = colData(vsd)$Batch,
  design = model.matrix(~ cell_type, data = as.data.frame(colData(vsd)))
)

# Collapse replicates → one column per cell line
cell_types <- as.character(colData(vsd)$cell_type)
vst_df <- as.data.frame(vst_bc) |> tibble::rownames_to_column("gene")

vst_avg <- vst_df |>
  tidyr::pivot_longer(-gene, names_to = "sample", values_to = "vst") |>
  dplyr::mutate(cell_line = cell_types[match(sample, colnames(vst_bc))]) |>
  dplyr::group_by(gene, cell_line) |>
  dplyr::summarise(vst = mean(vst, na.rm = TRUE), .groups = "drop") |>
  tidyr::pivot_wider(names_from = cell_line, values_from = vst)

# Save the averaged VST matrix (genes × cell_line)
expr_tsv <- file.path(out_root, "expr_matrix_vst_by_cellline.tsv")
readr::write_tsv(vst_avg, expr_tsv)

# Compute PARPi biomarker metrics (CORE list)

# Core markers & direction:
#   parpi_pos (↑ → sensitivity): SLFN11, PARP1
#   parpi_neg (↑ → resistance):  ATM, CHEK1, XRCC1, BRCA2, ABCB1, ABCG2, PRKDC
parpi_pos <- c("SLFN11","PARP1")
parpi_neg <- c("ATM","CHEK1","XRCC1","BRCA2","ABCB1","ABCG2","PRKDC")
markers_all <- c(parpi_pos, parpi_neg)

# Long table of expression (from vst_avg already computed above)
expr_long <- vst_avg |>
  tidyr::pivot_longer(-gene, names_to = "cell_line", values_to = "vst")

# Wide table of marker VST (for export/inspection)
markers_vst <- expr_long |>
  dplyr::filter(gene %in% markers_all) |>
  tidyr::pivot_wider(names_from = gene, values_from = vst)

# Build gene x cell_line matrix and z-score each gene across cell lines 
mat_gxcl <- vst_avg |>
  dplyr::filter(gene %in% markers_all) |>
  tibble::column_to_rownames("gene") |>
  as.matrix()

if (nrow(mat_gxcl) == 0) {
  stop("None of the PARPi marker genes were found in the VST matrix.")
}

z_gxcl <- t(scale(t(mat_gxcl)))                               # z-score by gene
z_df   <- as.data.frame(z_gxcl) |> tibble::rownames_to_column("gene")

# Talazoparib Sensitivity Index (TSI): mean(z of pos) − mean(z of neg)
z_long <- z_df |>
  tidyr::pivot_longer(-gene, names_to = "cell_line", values_to = "z") |>
  dplyr::mutate(class = dplyr::case_when(
    gene %in% parpi_pos ~ "pos",
    gene %in% parpi_neg ~ "neg",
    TRUE ~ NA_character_
  )) |>
  tidyr::drop_na(class)

tsi_tbl <- z_long |>
  dplyr::group_by(cell_line, class) |>
  dplyr::summarise(z_mean = mean(z, na.rm = TRUE), .groups = "drop") |>
  tidyr::pivot_wider(names_from = class, values_from = z_mean) |>
  dplyr::mutate(TSI_signed_z = pos - neg)

# Efflux_index (higher value = less efflux = more sensitivity)
# Compute per-cell-line mean z for ABCB1/ABCG2, then flip sign.
efflux_genes <- intersect(c("ABCB1","ABCG2"), rownames(z_gxcl))
efflux_index <- if (length(efflux_genes) > 0) {
  base::colMeans(z_gxcl[efflux_genes, , drop = FALSE], na.rm = TRUE)
} else {
  base::setNames(rep(NA_real_, ncol(z_gxcl)), colnames(z_gxcl))
}

tsi_tbl <- tsi_tbl |>
  dplyr::mutate(
    Efflux_index = -efflux_index[ match(cell_line, names(efflux_index)) ]
  )

# Merge individual VST markers with composite indices
parpi_metrics <- markers_vst |>
  dplyr::right_join(tsi_tbl, by = "cell_line")

# Rename available marker columns with _vst suffix (guard if some missing)
rename_cols <- intersect(markers_all, names(parpi_metrics))
parpi_metrics <- parpi_metrics |>
  dplyr::rename_with(~ paste0(.x, "_vst"), .cols = dplyr::all_of(rename_cols)) |>
  dplyr::relocate(cell_line, TSI_signed_z, Efflux_index)

# Export metrics
readr::write_csv(parpi_metrics, file.path(out_root, "parpi_core_metrics_vst.csv"))


# Correlate with Talazoparib IC50 / AUC (death-scale & AUC-1)
drug <- readr::read_csv(
  tzb_csv,
  col_types = readr::cols(
    cell_line = readr::col_character(),
    IC50_nM   = readr::col_double(),
    AUC       = readr::col_double()
  )
) |>
  dplyr::mutate(
    AUC_death     = AUC,        # 1 = death, 0 = viability
    AUC_viability = 1 - AUC
  )

dat <- dplyr::inner_join(drug, parpi_metrics, by = "cell_line")

metrics   <- c("TSI_signed_z","SLFN11_vst","PARP1_vst","Efflux_index")
metrics   <- metrics[metrics %in% names(dat)]  # guard
endpoints <- c("IC50_nM","AUC_death","AUC_viability")

# quick table (rho/r)
corr_tbl <- purrr::map_dfr(metrics, function(m) {
  purrr::map_dfr(endpoints, function(e) {
    sub <- dat |> dplyr::select(all_of(c("cell_line", m, e))) |> tidyr::drop_na()
    tibble::tibble(
      metric    = m,
      endpoint  = e,
      n         = nrow(sub),
      spearman  = if (nrow(sub) >= 3) cor(sub[[m]], sub[[e]], method = "spearman") else NA_real_,
      pearson   = if (nrow(sub) >= 3) cor(sub[[m]], sub[[e]], method = "pearson")  else NA_real_
    )
  })
})
readr::write_csv(corr_tbl, file.path(out_root, "talazoparib_correlations.csv"))

# Detailed stats (saved & reused for plot stamps)
summarize_corr <- function(df, x, y) {
  sub <- df |> dplyr::select(x = !!rlang::sym(x), y = !!rlang::sym(y)) |> tidyr::drop_na()
  n   <- nrow(sub)
  pe  <- if (n >= 3) suppressWarnings(cor.test(sub$x, sub$y, method = "pearson"))  else NULL
  sp  <- if (n >= 3) suppressWarnings(cor.test(sub$x, sub$y, method = "spearman")) else NULL
  tibble::tibble(
    n            = n,
    pearson_r    = if (!is.null(pe)) unname(pe$estimate) else NA_real_,
    pearson_p    = if (!is.null(pe)) pe$p.value          else NA_real_,
    pearson_r2   = if (!is.null(pe)) unname(pe$estimate)^2 else NA_real_,
    pearson_ci_l = if (!is.null(pe) && !is.null(pe$conf.int)) pe$conf.int[1] else NA_real_,
    pearson_ci_u = if (!is.null(pe) && !is.null(pe$conf.int)) pe$conf.int[2] else NA_real_,
    spearman_rho = if (!is.null(sp)) unname(sp$estimate) else NA_real_,
    spearman_p   = if (!is.null(sp)) sp$p.value          else NA_real_
  )
}

corr_detailed <- purrr::map_dfr(metrics, function(m) {
  purrr::map_dfr(endpoints, function(e) {
    summarize_corr(dat, m, e) |> dplyr::mutate(metric = m, endpoint = e, .before = 1)
  })
})

corr_detailed_num <- corr_detailed |>
  dplyr::mutate(
    n            = as.integer(n),
    pearson_r    = as.numeric(pearson_r),
    pearson_p    = as.numeric(pearson_p),
    pearson_r2   = as.numeric(pearson_r2),
    pearson_ci_l = as.numeric(pearson_ci_l),
    pearson_ci_u = as.numeric(pearson_ci_u),
    spearman_rho = as.numeric(spearman_rho),
    spearman_p   = as.numeric(spearman_p)
  )
readr::write_csv(corr_detailed_num, file.path(out_root, "talazoparib_correlations_detailed.csv"))

# Shared Y-axis ranges (consistent IC50 vs AUC plots)
y_ic50_range <- range(dat$IC50_nM, na.rm = TRUE)
y_auc_range  <- range(c(dat$AUC_death, dat$AUC_viability), na.rm = TRUE)

# Plotting helper: stamps read FROM saved table
get_stats_label <- function(metric, endpoint, stats_df = corr_detailed_num) {
  row <- stats_df |> dplyr::filter(metric == !!metric, endpoint == !!endpoint)
  if (nrow(row) != 1) return("n = NA\nr = NA (p=NA),  r² = NA\nρ = NA (p=NA)")
  fmt <- function(x, d = 2) {
    x <- as.numeric(x)
    if (is.na(x)) "NA" else if (x < 1e-3) formatC(x, format = "e", digits = 1) else formatC(x, format = "f", digits = d)
  }
  paste0(
    "n = ", row$n,
    "\nr = ", fmt(row$pearson_r), " (p=", fmt(row$pearson_p), "),  r² = ", fmt(row$pearson_r2),
    "\nρ = ", fmt(row$spearman_rho), " (p=", fmt(row$spearman_p), ")"
  )
}

# Plot: one label per unique cell_line + compact side stamp
plot_one_cellline_labels <- function(xvar, yvar, data = dat, label_agg = c("mean","median")) {
  label_agg <- match.arg(label_agg)
  agg_fun <- if (label_agg == "median") stats::median else base::mean

  df <- data |>
    dplyr::select(cell_line, x = !!rlang::sym(xvar), y = !!rlang::sym(yvar)) |>
    tidyr::drop_na()

  df_lab <- df |>
    dplyr::group_by(cell_line) |>
    dplyr::summarise(
      x = agg_fun(x, na.rm = TRUE),
      y = agg_fun(y, na.rm = TRUE),
      .groups = "drop"
    )

  stats_lab <- get_stats_label(metric = xvar, endpoint = yvar, stats_df = corr_detailed_num)

  y_limits <- if (yvar == "IC50_nM") y_ic50_range else
              if (yvar %in% c("AUC_death","AUC_viability")) y_auc_range else NULL

  n_labs <- nrow(df_lab)
  txt_sz <- if (n_labs <= 10) 3.8 else if (n_labs <= 20) 3.2 else if (n_labs <= 35) 2.8 else 2.6
  base_w <- if (n_labs <= 12) 6.6 else if (n_labs <= 24) 7.4 else 8.2
  base_h <- if (n_labs <= 12) 4.6 else if (n_labs <= 24) 5.1 else 5.6

  subtitle <- if (yvar == "IC50_nM") {
    "Expectation: higher TSI/SLFN11/PARP1 → lower IC50 (negative correlation)"
  } else if (yvar == "AUC_death") {
    "Expectation: higher TSI/SLFN11/PARP1 → higher AUC_death (positive correlation)"
  } else if (yvar == "AUC_viability") {
    "Expectation: higher TSI/SLFN11/PARP1 → lower AUC_viability (negative correlation)"
  } else { "" }

  p_main <- ggplot() +
    geom_point(data = df, aes(x = x, y = y), size = 2.4, alpha = 0.45) +
    geom_point(data = df_lab, aes(x = x, y = y), size = 2.8, alpha = 0.9) +
    ggrepel::geom_text_repel(
      data = df_lab, aes(x = x, y = y, label = cell_line),
      max.overlaps = Inf, size = txt_sz, label.size = NA,
      label.padding = grid::unit(0.15, "lines"),
      box.padding   = grid::unit(0.35, "lines"),
      point.padding = grid::unit(0.15, "lines"),
      min.segment.length = 0, segment.size = 0.25,
      seed = 42, force = 0.6, force_pull = 0.4
    ) +
    geom_smooth(data = df, aes(x = x, y = y), method = "lm", se = FALSE, linewidth = 0.6) +
    { if (is.null(y_limits)) scale_y_continuous() else scale_y_continuous(limits = y_limits) } +
    labs(x = xvar, y = yvar, title = paste("Talazoparib:", yvar, "vs", xvar), subtitle = subtitle) +
    theme_minimal(base_size = 12) +
    theme(plot.margin = margin(10, 10, 10, 10), legend.position = "none")

  # Compact side stamp
  nl   <- length(strsplit(stats_lab, "\n")[[1]])
  s_w  <- 0.20
  s_h  <- min(0.45, max(0.22, 0.055 * nl + 0.06))
  s_y  <- (1 - s_h) / 2

  stamp_plot <- ggplot() +
    coord_cartesian(xlim = c(0, 1), ylim = c(0, 1), expand = FALSE) +
    theme_void() +
    annotate("rect", xmin = 0, xmax = 1, ymin = 0, ymax = 1,
             fill = "white", alpha = 1, colour = "grey85", linewidth = 0.35) +
    annotate("text", x = 0.04, y = 0.5, hjust = 0, vjust = 0.5,
             label = stats_lab, size = 2.4, lineheight = 1.05)

  dir.create(file.path(out_root, "plots"), showWarnings = FALSE, recursive = TRUE)
  fn <- file.path(out_root, "plots",
                  paste0(yvar, "_vs_", xvar, "_ONE_LABEL_PER_CELL_LINE.png"))
  ggsave(fn, p_main, width = base_w, height = base_h, dpi = 600) # save main too (optional)
  ggsave(gsub(".png$", "_STAMPED.png", fn), p_main, width = base_w, height = base_h, dpi = 600) # placeholder

  p_final <- cowplot::ggdraw() +
    cowplot::draw_plot(p_main,     x = 0,        y = 0,   width = 1 - s_w, height = 1, hjust = 0, vjust = 0) +
    cowplot::draw_plot(stamp_plot, x = 1 - s_w,  y = s_y, width = s_w,     height = s_h, hjust = 0, vjust = 0)

  ggsave(fn, p_final, width = base_w + 0.9, height = base_h, dpi = 600)
  p_final
}

# Build all panels with PARPi metrics
for (m in c("TSI_signed_z","SLFN11_vst","PARP1_vst","Efflux_index")) {
  for (e in c("IC50_nM","AUC_death","AUC_viability")) {
    if (m %in% names(dat)) plot_one_cellline_labels(m, e, data = dat, label_agg = "mean")
  }
}

message("Done. Outputs in: ", out_root,
        "\n- expr_matrix_vst_by_cellline.tsv",
        "\n- parpi_core_metrics_vst.csv",
        "\n- talazoparib_correlations.csv",
        "\n- talazoparib_correlations_detailed.csv",
        "\n- plots/*_ONE_LABEL_PER_CELL_LINE.png")

```



```{r}
# Per-cell line residual summaries & interpretation (Talazoparib)

suppressPackageStartupMessages({
  library(dplyr); library(tidyr); library(readr)
  library(broom)
})

# One point per cell line (mean of replicates; same aggregation as plots)
per_line <- dat %>%
  dplyr::select(
    cell_line,
    TSI_signed_z, SLFN11_vst, PARP1_vst, Efflux_index,
    IC50_nM, AUC_death, AUC_viability
  ) %>%
  dplyr::group_by(cell_line) %>%
  dplyr::summarise(
    TSI_signed_z = mean(TSI_signed_z, na.rm = TRUE),
    SLFN11_vst   = mean(SLFN11_vst,   na.rm = TRUE),
    PARP1_vst    = mean(PARP1_vst,    na.rm = TRUE),
    Efflux_index = mean(Efflux_index, na.rm = TRUE),
    IC50_nM      = mean(IC50_nM,      na.rm = TRUE),
    AUC_death    = mean(AUC_death,    na.rm = TRUE),
    AUC_viability= mean(AUC_viability,na.rm = TRUE),
    .groups = "drop"
  ) %>%
  tidyr::drop_na()

# Helper: fit model, get residuals (raw & standardized), and label interpretation
get_residual_table <- function(df, x, y, slope_expect = c("neg","pos")) {
  slope_expect <- match.arg(slope_expect)
  fm <- stats::lm(stats::reformulate(x, response = y), data = df)
  aug <- broom::augment(fm, data = df) %>%
    dplyr::transmute(
      cell_line = .data$cell_line,
      x         = .data[[x]],
      y         = .data[[y]],
      .resid,
      .std.resid
    )
  interpret <- if (slope_expect == "neg") {
    ifelse(aug$.resid < 0, "More sensitive than predicted",
           ifelse(aug$.resid > 0, "Less sensitive than predicted", "As predicted"))
  } else {
    ifelse(aug$.resid > 0, "More sensitive than predicted",
           ifelse(aug$.resid < 0, "Less sensitive than predicted", "As predicted"))
  }
  aug %>%
    dplyr::mutate(
      metric            = x,
      endpoint          = y,
      resid             = .resid,
      resid_std         = .std.resid,
      sensitivity_vs_pred = interpret
    ) %>%
    dplyr::select(cell_line, metric, endpoint, x, y, resid, resid_std, sensitivity_vs_pred)
}

# Tables for each endpoint using TSI as X
tab_ic50_tsi  <- get_residual_table(per_line, x = "TSI_signed_z", y = "IC50_nM",       slope_expect = "neg")
tab_aucD_tsi  <- get_residual_table(per_line, x = "TSI_signed_z", y = "AUC_death",     slope_expect = "pos")
tab_aucV_tsi  <- get_residual_table(per_line, x = "TSI_signed_z", y = "AUC_viability", slope_expect = "neg")

# (Optional) Repeat for SLFN11 as X
tab_ic50_slfn <- get_residual_table(per_line, x = "SLFN11_vst",   y = "IC50_nM",       slope_expect = "neg")
tab_aucD_slfn <- get_residual_table(per_line, x = "SLFN11_vst",   y = "AUC_death",     slope_expect = "pos")
tab_aucV_slfn <- get_residual_table(per_line, x = "SLFN11_vst",   y = "AUC_viability", slope_expect = "neg")

# Flag notable deviations (|standardized residual| > 2 ~ large; > 3 ~ very large)
flag_deviation <- function(z) ifelse(is.na(z), "NA",
                                     ifelse(abs(z) >= 3, "very_large",
                                            ifelse(abs(z) >= 2, "large", "ok")))
tab_ic50_tsi  <- tab_ic50_tsi  %>% dplyr::mutate(deviation_flag = flag_deviation(resid_std))
tab_aucD_tsi  <- tab_aucD_tsi  %>% dplyr::mutate(deviation_flag = flag_deviation(resid_std))
tab_aucV_tsi  <- tab_aucV_tsi  %>% dplyr::mutate(deviation_flag = flag_deviation(resid_std))
tab_ic50_slfn <- tab_ic50_slfn %>% dplyr::mutate(deviation_flag = flag_deviation(resid_std))
tab_aucD_slfn <- tab_aucD_slfn %>% dplyr::mutate(deviation_flag = flag_deviation(resid_std))
tab_aucV_slfn <- tab_aucV_slfn %>% dplyr::mutate(deviation_flag = flag_deviation(resid_std))

# Combined deviation score (IC50↓ + AUC_death↑) using TSI as predictor
dev_combo_tsi <- tab_ic50_tsi %>%
  dplyr::select(cell_line, ic50_resid_std = resid_std) %>%
  dplyr::left_join(tab_aucD_tsi %>% dplyr::select(cell_line, aucD_resid_std = resid_std), by = "cell_line") %>%
  dplyr::mutate(sensitivity_deviation_score = (-ic50_resid_std + aucD_resid_std) / 2) %>%
  dplyr::arrange(dplyr::desc(sensitivity_deviation_score))

# Save outputs
out_dir <- file.path(out_root, "per_cell_line_residuals"); dir.create(out_dir, FALSE, TRUE)
readr::write_csv(tab_ic50_tsi,  file.path(out_dir, "residuals_TSI_vs_IC50.csv"))
readr::write_csv(tab_aucD_tsi,  file.path(out_dir, "residuals_TSI_vs_AUC_death.csv"))
readr::write_csv(tab_aucV_tsi,  file.path(out_dir, "residuals_TSI_vs_AUC_viability.csv"))
readr::write_csv(tab_ic50_slfn, file.path(out_dir, "residuals_SLFN11_vs_IC50.csv"))
readr::write_csv(tab_aucD_slfn, file.path(out_dir, "residuals_SLFN11_vs_AUC_death.csv"))
readr::write_csv(tab_aucV_slfn, file.path(out_dir, "residuals_SLFN11_vs_AUC_viability.csv"))
readr::write_csv(dev_combo_tsi, file.path(out_dir, "combined_sensitivity_deviation_score_TSI.csv"))

message(
  "\nInterpretation:\n",
  "  sensitivity_deviation_score > 0 : more sensitive than predicted by TSI (averaging IC50↓ and AUC_death↑)\n",
  "  sensitivity_deviation_score < 0 : less sensitive than predicted\n",
  "  |resid_std| ≥ 2 in the per-endpoint tables flags large deviations.\n",
  "\nOutputs written to: ", out_dir, "\n"
)


```

