---
title: "RNSseq STAR_RSEM DESEq2 and GSEA for drug sensitivities of STS cell lines with drug-gene targeted panels"
output: html_document
editor_options: 
  chunk_output_type: inline
---



# Load packages from library
```{r}
library(DESeq2)
library(tximport)
library(readr)
library(dplyr)
library(tidyr)
library(wesanderson)
library(pheatmap)
library(ggplot2)
library(genefilter)
library(org.Hs.eg.db)
library(data.table); library(limma); library(fgsea); library(msigdbr)
library(AnnotationDbi); library(GSVA); library(ReactomePA)
library(STRINGdb); library(igraph); library(matrixStats)


```


#Read the sample information
```{r}
out_root <- file.path(getwd(), paste0("results_STS_", format(Sys.Date(), "%Y%m%d")))
dir.create(out_root, showWarnings = FALSE, recursive = TRUE)

sampleinfo <- read_csv("sampleinfo_STS_DrugSens_2025.csv")

if (interactive()) View(sampleinfo)
```



#The resulting object is a “list” structure in R which contains a number of components that we can access using a $ operator. The raw counts can be found using txi$counts. The names of each column are the sample names.
```{r}
rsem_counts <- read_tsv("left_merged_STS_Batches_1_2_gene_counts.tsv")
gene_names <- pull(rsem_counts, gene_id)

rsem_counts <- dplyr::select(rsem_counts, -c(1:2)) %>% as.matrix()
rownames(rsem_counts) <- gene_names


# Filter (>=10 counts in >=4 samples)
min_samps <- 4
keep_filt <- rowSums(rsem_counts >= 10) >= min_samps
message(sprintf("Keeping %d / %d genes (>=10 in >=%d samples).",
                sum(keep_filt), nrow(rsem_counts), min_samps))
rsem_counts <- rsem_counts[keep_filt, , drop = FALSE]

# Factors
sampleinfo$Batch     <- factor(sampleinfo$Batch)
sampleinfo$cell_type <- factor(sampleinfo$cell_type)

#Make sure colData rownames match count matrix columns before building any DESeqDataSet:
rownames(sampleinfo) <- sampleinfo$name 
stopifnot(all(colnames(rsem_counts) == rownames(sampleinfo)))


dds <- DESeqDataSetFromMatrix(
  countData = round(rsem_counts),
  colData   = sampleinfo,
  design    = ~ Batch + cell_type
)
```



```{r}
#Annotate a dds object with SYMBOL names for later use.

ens_cell_type <- rownames(rsem_counts)


symbols <- mapIds(org.Hs.eg.db, keys = ens_cell_type,
  column = c('SYMBOL'), keytype = 'ENSEMBL')
  symbols <- symbols[!is.na(symbols)]
  symbols <- symbols[match(rownames(rsem_counts), names(symbols))]
  rownames(rsem_counts) <- symbols
  keep <- !is.na(rownames(rsem_counts))
  rsem_counts_symbol <- rsem_counts[keep,]
  

#After mapping to symbols, there will likely be duplicate gene names. Collapse or make them unique before DESeqDataSetFromMatrix:  
rsem_counts_symbol <- rowsum(rsem_counts_symbol, group = rownames(rsem_counts_symbol))
  


#Setup & model fit
suppressPackageStartupMessages({
  library(DESeq2)
  library(tibble)
  library(dplyr)
})

# If needed for lfcShrink(type="ashr")
if (!requireNamespace("ashr", quietly = TRUE)) {
  install.packages("ashr")
}

# Ensure factors are clean
sampleinfo$cell_type <- droplevels(factor(sampleinfo$cell_type))
sampleinfo$Batch     <- droplevels(factor(sampleinfo$Batch))

dds_symbol <- DESeqDataSetFromMatrix(
  countData = round(rsem_counts_symbol),
  colData   = sampleinfo,
  design    = ~ Batch + cell_type
)

dds_symbol <- DESeq(dds_symbol)

# Overall results table (optional)
res_de_cell_type_symbol <- results(dds_symbol, tidy = TRUE)

# Build all unique pairwise contrasts
cell_lvls <- levels(colData(dds_symbol)$cell_type)
pairs <- combn(cell_lvls, 2, simplify = FALSE)

# Containers
pair_res_list      <- list()  # results()
pair_lfcshrink_list <- list() # lfcShrink()

# Output directory
out_dir <- "deseq2_pairwise_cell_type"
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

# Loop over all pairs
for (pb in pairs) {
  A <- pb[1]
  B <- pb[2]
  cname <- paste0(A, "_vs_", B)

  # Raw DE results (tidy)
  res_ab <- results(
    dds_symbol,
    contrast = c("cell_type", A, B),
    alpha    = 0.05,
    tidy     = TRUE
  ) %>%
    mutate(contrast = cname)

  pair_res_list[[cname]] <- res_ab
  write.csv(res_ab, file.path(out_dir, paste0("DE_", cname, "_results.csv")), row.names = FALSE)

  # Shrunk LFCs (ashr). DESeqResults with rownames = gene IDs
  lfc_ab <- lfcShrink(
    dds     = dds_symbol,
    contrast = c("cell_type", A, B),
    type    = "ashr"
  )

  lfc_ab_df <- as.data.frame(lfc_ab) %>%
    rownames_to_column(var = "row") %>%
    mutate(contrast = cname)

  pair_lfcshrink_list[[cname]] <- lfc_ab_df
  write.csv(lfc_ab_df, file.path(out_dir, paste0("DE_", cname, "_LFCshrink_ashr.csv")), row.names = FALSE)
}

# save everything together as RDS
saveRDS(
  list(
    raw_results   = pair_res_list,
    lfc_shrunk    = pair_lfcshrink_list,
    overall_tidy  = res_de_cell_type_symbol
  ),
  file = file.path(out_dir, "all_pairwise_DESeq2_cell_type_results.rds")
)


```



#Quality control of the imported counts
```{r}

colData(dds)

```

#The metadata columns can also be re-assigned. This useful in this case because we can see that condition is not stored as a factor.
```{r}

dds$chem <- as.factor(dds$chem)
dds$rad <- as.factor(dds$rad)
dds$cell_type <- as.factor(dds$cell_type)
dds$Replicate <- as.numeric(dds$Replicate)
dds$Lineage <- as.factor(dds$Lineage)
dds$name <- as.factor(dds$name)

colData(dds)

```



```{r}
sum(counts(dds)[,1])

colSums(counts(dds))



boxplot(counts(dds))

mutate(sampleinfo, LibSize = colSums(assay(dds))/1e5) %>% 
  ggplot(aes(x = name, y = LibSize)) + geom_col(fill="steelblue") + geom_hline(yintercept = 200,col="red",lty=2) + scale_x_discrete(guide = guide_axis(angle = 45))

```



```{r}
dds_SF <- estimateSizeFactors(dds)
dds_Disp <- estimateDispersions(dds_SF)

plotDispEsts(dds_Disp)
```



#Visualising count distributions. We can use the vst or rlog function from DESeq2to compensate for the effect of different library sizes and put the data on the log2  scale. The effect is to remove the dependence of the variance on the mean, particularly the high variance of the logarithm of count data when the mean is low. 
```{r}
vsd <- vst(dds,blind=FALSE)
rld <- rlog(dds, blind = FALSE)



df <- bind_rows(
  as_data_frame(log2(counts(dds_SF, normalized=TRUE)[, 1:2]+1)) %>%
         mutate(transformation = "log2(x + 1)"),
  as_data_frame(assay(vsd)[, 1:2]) %>% mutate(transformation = "vst"),
  as_data_frame(assay(rld)[, 1:2]) %>% mutate(transformation = "rlog"))
  
colnames(df)[1:2] <- c("x", "y")  

lvls <- c("log2(x + 1)", "vst", "rlog")
df$transformation <- factor(df$transformation, levels=lvls)

ggplot(df, aes(x = x, y = y)) + geom_hex(bins = 80) +
  coord_fixed() + facet_grid( . ~ transformation) 



#QC: VST + PCA; vis-only batch removal
#Quick check whether batch drives clustering; removeBatchEffect only for plots—not for DE tests.

rsem_counts <- read_tsv("left_merged_STS_Batches_1_2_gene_counts.tsv")
gene_names <- pull(rsem_counts, gene_id)

rsem_counts <- dplyr::select(rsem_counts, -c(1:2)) %>% as.matrix()
rownames(rsem_counts) <- gene_names


# Filter (>=10 counts in >=4 samples)
min_samps <- 4
keep_filt <- rowSums(rsem_counts >= 10) >= min_samps
message(sprintf("Keeping %d / %d genes (>=10 in >=%d samples).",
                sum(keep_filt), nrow(rsem_counts), min_samps))
rsem_counts <- rsem_counts[keep_filt, , drop = FALSE]

# Factors
sampleinfo$Batch     <- factor(sampleinfo$Batch)
sampleinfo$cell_type <- factor(sampleinfo$cell_type)

#Make sure colData rownames match count matrix columns before building any DESeqDataSet:
rownames(sampleinfo) <- sampleinfo$name
stopifnot(all(colnames(rsem_counts) == rownames(sampleinfo)))
dds_qc <- DESeqDataSetFromMatrix(
  countData = round(rsem_counts),
  colData   = sampleinfo,
  design    = ~ Batch + cell_type
)

vst_qc <- vst(dds_qc, blind = TRUE)

p1 <- plotPCA(vst_qc, intgroup = c("cell_type", "Batch"), ntop = 2000) + ggtitle("PCA (VST, uncorrected)")
ggsave(file.path(out_root, "PCA_vst_uncorrected.pdf"), p1, width=6, height=5)

vst_bc <- removeBatchEffect(assay(vst_qc),
                            batch  = colData(vst_qc)$Batch,
                            design = model.matrix(~ cell_type, data = as.data.frame(colData(vst_qc))))
vst_bc_se <- vst_qc; assay(vst_bc_se) <- vst_bc

p2 <- plotPCA(vst_bc_se, intgroup="Batch") + ggtitle("PCA (VST, batch removed)")
ggsave(file.path(out_root, "PCA_vst_batch_removed.pdf"), p2, width=6, height=5)

p3 <- plotPCA(vst_bc_se, intgroup = c("cell_type", "Batch"), ntop = 2000) +
  ggtitle("PCA (VST, batch-removed with cell type as co-factor)")
ggsave(file.path(out_root, "PCA_vst_batch_removed_celltype.pdf"), p3, width=6, height=5)


```



```{r}
# Get log2 counts
vsd <- vst(dds,blind=TRUE)

# Check distributions of samples using boxplots
boxplot(assay(vsd), xlab="", ylab="Log2 counts per million",las=2,main="Normalised Distributions")

abline(h=median(assay(vsd)), col="blue")

```


# Principal components Analysis (PCA).
```{r}
library("ggrepel")

plotPCA(vsd,intgroup="cell_type")

PCAplot <- plotPCA(vsd,intgroup="cell_type",returnData = TRUE) %>% 
  dplyr::rename(cell_line = cell_type) %>% 
  left_join(sampleinfo) %>% 
  ggplot(aes(x = PC1, y = PC2,col="group")) + geom_point(size=2)

PCAplot


PCAplot + scale_color_manual(values = c("#D55E00", "#D41159", "#000000", "#117733", "#332288", "#FF00FF", "#00CC33", "#0000FF", "#FFC20A"))+ theme(axis.text = element_text(size = 15))+ theme(axis.title = element_text(size = 15))+ theme(legend.text = element_text(size = 15)) + theme(legend.title = element_text(size = 15)) 


pcaData_cell_type = plotPCA(vsd, intgroup="cell_type",returnData=TRUE)
percentVar = round(100 * attr(pcaData_cell_type, "percentVar"))

png("DGE_PCA-vst Cell Type.RSEM.png", width=7, height=7, units = "in", res = 300)
ggplot(pcaData_cell_type, aes(PC1, PC2, colour = cell_type)) + 
geom_point(size = 2) + theme_bw() + 
scale_color_manual(values = c("#D55E00", "#D41159", "#000000", "#117733", "#332288", "#FF00FF", "#00CC33", "#0000FF", "#FFC20A")) +
geom_text_repel(aes(label = cell_type), nudge_x = -1, nudge_y = 0.2, size = 2) +
ggtitle("Principal Component Analysis (PCA) STS Cell Lines", subtitle = "vst transformation") +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance"))

```


#It is a good idea to save the results of the pre-processing so we don’t have to repeat it every time.
```{r}

dir.create("Robjects_cell_type/",showWarnings = FALSE)
saveRDS(dds, file="Robjects_cell_type/dds.rds")


dir.create("Robjects_cell_type/",showWarnings = FALSE)
saveRDS(dds_symbol, file="Robjects_cell_type/dds_symbol.rds") 

```

#Retrieve saved R object to dataset
```{r}
dds <- readRDS("Robjects_cell_type/dds.rds")
```


#DESeq workflow. Set design for DESeq object, in this case we want to look at differential expression amongst the different cell types while correcting for batch effects.
```{r}
colData(dds)
design(dds) <- ~ Batch + cell_type
de_cell_type <- DESeq(dds)
```



```{r}
suppressPackageStartupMessages({
  library(DESeq2)
  library(dplyr)
  library(readr)
  library(tibble)
  library(ggplot2)
})

# Load fitted DESeqDataSet
dds <- readRDS("Robjects_cell_type/dds.rds")

# Fit with desired design
design(dds) <- ~ Batch + cell_type
de_cell_type <- DESeq(dds)

# Pairwise contrasts
cell_lvls <- levels(colData(de_cell_type)$cell_type)
stopifnot(length(cell_lvls) >= 2)
pairs <- combn(cell_lvls, 2, simplify = FALSE)

# Output folders
dir.create("de_analysis", showWarnings = FALSE, recursive = TRUE)
dir.create("Robjects",    showWarnings = FALSE, recursive = TRUE)
dir.create("plots",       showWarnings = FALSE, recursive = TRUE)

# shrunken LFCs for MA plots (optional)
use_ashr <- requireNamespace("ashr", quietly = TRUE)

# Collect counts per contrast
de_counts <- list()

for (pb in pairs) {
  A <- pb[1]; B <- pb[2]
  base <- paste0("cell_type_", A, "_vs_", B)

  # DESeq results (controls padj/pvalue)
  res <- results(de_cell_type, contrast = c("cell_type", A, B), alpha = 0.05)

  res_df <- as.data.frame(res) %>%
    rownames_to_column(var = "gene") %>%
    as_tibble()

  # Remove NAs before saving 
  res_all_nona <- res_df %>% tidyr::drop_na(padj)
  res_sig_nona <- res_df %>% tidyr::drop_na(padj) %>% filter(padj < 0.05)

  # Save ALL and SIG (NA-removed)
  res_all_nona %>%
    arrange(padj) %>%
    write_csv(file.path("de_analysis", paste0(base, "_DESeq_all.csv")))
  write_csv(res_sig_nona,
            file.path("de_analysis", paste0(base, "_DESeq_sig.csv")))

  # Save raw DESeqResults object
  saveRDS(res, file = file.path("Robjects", paste0(base, ".rds")))

  # --- Counts ---
  n_de_p     <- res_df %>% tidyr::drop_na(pvalue) %>% summarize(n = sum(pvalue < 0.05)) %>% pull(n)
  n_de_padj  <- res_df %>% tidyr::drop_na(padj)   %>% summarize(n = sum(padj   < 0.05)) %>% pull(n)

  # For fold-change thresholding use the plotting object (shrunken if available)
  plot_res <- if (use_ashr) {
    lfcShrink(de_cell_type, contrast = c("cell_type", A, B), type = "ashr")
  } else {
    res
  }
  plot_df <- as.data.frame(plot_res) %>%
    rownames_to_column(var = "gene") %>%
    as_tibble() %>%
    # keep padj from plot_res (present) for consistent colouring
    tidyr::drop_na(baseMean, log2FoldChange)  # drop rows that cannot be plotted

  # Add categories for colouring
  plot_df <- plot_df %>%
    mutate(
      x = log10(baseMean + 1),
      cat = dplyr::case_when(
        !is.na(padj) & padj < 0.05 & log2FoldChange >  0.58 ~ "sig_up_fc",
        !is.na(padj) & padj < 0.05 & log2FoldChange < -0.58 ~ "sig_down_fc",
        !is.na(padj) & padj < 0.05                         ~ "sig_padj_only",
        TRUE                                               ~ "ns"
      ),
      cat = factor(cat, levels = c("ns","sig_padj_only","sig_up_fc","sig_down_fc"))
    )

  n_up   <- sum(plot_df$cat == "sig_up_fc", na.rm = TRUE)
  n_down <- sum(plot_df$cat == "sig_down_fc", na.rm = TRUE)

  de_counts[[base]] <- tibble(
    contrast = paste0(A, "_vs_", B),
    n_DE_p_lt_0_05    = n_de_p,
    n_DE_padj_lt_0_05 = n_de_padj,
    n_DE_up_LFCgt0_58_padjlt0_05 = n_up,
    n_DE_down_LFCltm0_58_padjlt0_05 = n_down
  )

  # Colour-based MA plot with colour-matched labels
  cols <- c(
    ns             = "grey80",
    sig_padj_only  = "orange",
    sig_up_fc      = "firebrick",
    sig_down_fc    = "royalblue"
  )

  p <- ggplot(plot_df, aes(x = x, y = log2FoldChange, colour = cat)) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    geom_hline(yintercept = c(-0.58, 0.58), linetype = "dotted") +
    geom_point(size = 1.2, alpha = 0.8) +
    scale_color_manual(
      name = NULL,
      values = cols,
      labels = c(
        ns = "Not significant",
        sig_padj_only = "padj < 0.05",
        sig_up_fc = "padj < 0.05 & LFC > 0.58",
        sig_down_fc = "padj < 0.05 & LFC < -0.58"
      )
    ) +
    labs(
      title = paste0(base, if (use_ashr) " (ashr shrinkage)" else " (unshrunken)"),
      subtitle = sprintf("# DE: p<0.05=%d | padj<0.05=%d | up>|0.58|=%d | down>|0.58|=%d",
                         n_de_p, n_de_padj, n_up, n_down),
      x = "log10(baseMean + 1)",
      y = "log2 fold change"
    ) +
    theme_minimal(base_size = 12) +
    theme(legend.position = "right")

  # Add colour-matched text labels inside the plot area (top-right)
  # Use Inf coordinates with hjust/vjust to anchor
  p <- p +
    annotate("text", x = Inf, y = Inf,
             label = paste0("UP (padj<0.05 & LFC>0.58): ", n_up),
             hjust = 1.02, vjust = 2.3, colour = cols["sig_up_fc"], size = 4) +
    annotate("text", x = Inf, y = Inf,
             label = paste0("DOWN (padj<0.05 & LFC< -0.58): ", n_down),
             hjust = 1.02, vjust = 3.5, colour = cols["sig_down_fc"], size = 4) +
    annotate("text", x = Inf, y = Inf,
             label = paste0("padj<0.05: ", n_de_padj),
             hjust = 1.02, vjust = 4.7, colour = cols["sig_padj_only"], size = 4)

  ggsave(file.path("plots", paste0(base, "_MA.png")), p, width = 8, height = 6, dpi = 150)
}

# Save summary counts
bind_rows(de_counts) %>%
  arrange(desc(n_DE_padj_lt_0_05)) %>%
  write_csv(file.path("de_analysis", "DE_counts_by_contrast.csv"))

message("Done. NA-removed tables in 'de_analysis/', plots in 'plots/', DESeqResults in 'Robjects/'.")

```


#Add heatmap clustering per contrast, using VST-transformed counts with viz-only batch removal, and saving heatmaps for: - Top DE genes per contrast (up to top_n up and top_n down at padj < 0.05 & |LFC| > 0.58), - a  fallback all significant (padj < 0.05) heatmap if too few pass the LFC threshold.
```{r}
suppressPackageStartupMessages({
  library(DESeq2); library(dplyr); library(tibble)
  library(pheatmap); library(limma); library(matrixStats)
})

# VST (vis-only batch removal)
vst_all <- vst(de_cell_type, blind = FALSE)
vst_mat <- assay(vst_all)
vst_mat_bc <- removeBatchEffect(
  vst_mat,
  batch  = colData(vst_all)$Batch,
  design = model.matrix(~ cell_type, data = as.data.frame(colData(vst_all)))
)

# Annotation & palette
ann_col <- as.data.frame(colData(vst_all)[, c("cell_type","Batch")])
rownames(ann_col) <- colnames(vst_mat_bc)
pal <- colorRampPalette(c("navy","white","firebrick3"))(101)

dir.create("plots/heatmaps", showWarnings = FALSE, recursive = TRUE)

zscore <- function(m){ m2 <- t(scale(t(m))); m2[is.na(m2)] <- 0; m2 }

top_n <- 50

sanitize <- function(x) gsub("[^A-Za-z0-9._-]+", "_", x)

for (pb in pairs) {
  A <- pb[1]; B <- pb[2]
  base <- paste0("cell_type_", sanitize(A), "_vs_", sanitize(B))

  # DE results for this contrast
  res_df <- results(de_cell_type, contrast = c("cell_type", A, B), alpha = 0.05) |>
    as.data.frame() |> rownames_to_column("gene") |> as_tibble()

  # primary selection: padj<0.05 & |LFC|>0.58
  sig_lfc <- res_df |> filter(!is.na(padj), padj < 0.05, !is.na(log2FoldChange), abs(log2FoldChange) > 0.58)
  top_up  <- sig_lfc |> arrange(desc(log2FoldChange)) |> slice_head(n = top_n) |> pull(gene)
  top_dn  <- sig_lfc |> arrange(     log2FoldChange ) |> slice_head(n = top_n) |> pull(gene)
  genes_primary <- unique(c(top_up, top_dn))

  # fallback 1: padj<0.05 best (up to 100)
  if (length(genes_primary) < 10) {
    sig_any <- res_df |> filter(!is.na(padj), padj < 0.05) |>
      arrange(padj, desc(abs(log2FoldChange))) |> slice_head(n = 100) |> pull(gene)
    genes_use <- unique(sig_any)
    tag <- if (length(genes_use) > 0) "sig_padj_only" else NA
  } else {
    genes_use <- genes_primary; tag <- "sig_padj_LFC"
  }

  # fallback 2: if still none, take top-variance genes across A/B samples (always plots)
  cols_ab <- colnames(vst_mat_bc)[colData(vst_all)$cell_type %in% c(A,B)]
  if (length(genes_use) == 0) {
    ab_mat <- vst_mat_bc[, cols_ab, drop = FALSE]
    v <- rowVars(ab_mat)
    genes_use <- names(sort(v, decreasing = TRUE))[seq_len(min(100, length(v)))]
    tag <- "topvar_AB"
  }

  # intersect with VST matrix rownames
  genes_use <- intersect(genes_use, rownames(vst_mat_bc))
  if (length(genes_use) == 0) {
    message("No genes found to plot for ", base, " — skipping."); next
  }

  # matrices
  mat_all <- vst_mat_bc[genes_use, , drop = FALSE]
  mat_ab  <- mat_all[, cols_ab, drop = FALSE]

  mat_all_z <- zscore(mat_all)
  mat_ab_z  <- zscore(mat_ab)

  ann_all <- ann_col
  ann_ab  <- ann_col[colnames(mat_ab_z), , drop = FALSE]

  # save
  f_all <- file.path("plots/heatmaps", paste0(base, "_", tag, "_ALL.png"))
  png(f_all, width = 2400, height = 2400, res = 300)
  pheatmap(mat_all_z, color = pal, show_rownames = FALSE, show_colnames = TRUE,
           annotation_col = ann_all, clustering_distance_rows = "euclidean",
           clustering_distance_cols = "euclidean", clustering_method = "complete",
           main = paste0(base, " — heatmap (", tag, "), all samples"))
  dev.off()

  f_ab <- file.path("plots/heatmaps", paste0(base, "_", tag, "_", sanitize(A), "_vs_", sanitize(B), ".png"))
  png(f_ab, width = 2000, height = 2000, res = 300)
  pheatmap(mat_ab_z, color = pal, show_rownames = FALSE, show_colnames = TRUE,
           annotation_col = ann_ab, clustering_distance_rows = "euclidean",
           clustering_distance_cols = "euclidean", clustering_method = "complete",
           main = paste0(base, " — heatmap (", tag, "), ", A, " vs ", B))
  dev.off()

  message("Saved: ", basename(f_all), " and ", basename(f_ab))
}

```


```{r}
suppressPackageStartupMessages({
  library(DESeq2)
  library(pheatmap)
  library(RColorBrewer)
})

# Use the fitted object if present; otherwise use dds
obj <- if (exists("de_cell_type")) de_cell_type else dds

# VST for distance computation
vsd <- vst(obj, blind = FALSE)

# Labels from colData$name (make unique just in case)
if (!"name" %in% colnames(colData(vsd))) {
  stop("'name' column not found in colData(dds).")
}
labels <- make.unique(as.character(colData(vsd)$name))

# Sample-to-sample (Euclidean) distances on VST expression
sample_dists <- dist(t(assay(vsd)))
dist_mat <- as.matrix(sample_dists)

# Apply labels
rownames(dist_mat) <- labels
colnames(dist_mat) <- labels

# Column annotations
ann_col <- data.frame(
  cell_type = factor(colData(vsd)$cell_type),
  Batch     = factor(colData(vsd)$Batch),
  row.names = labels
)

# High-contrast legend colors
# Okabe–Ito palette (colorblind-friendly, very contrasty)
okabe_ito <- c("#000000","#E69F00","#56B4E9","#009E73",
               "#F0E442","#0072B2","#D55E00","#CC79A7")

# cell_type colors (extend if >8 levels)
ct_lvls <- levels(ann_col$cell_type)
if (length(ct_lvls) <= length(okabe_ito)) {
  ct_cols <- okabe_ito[seq_along(ct_lvls)]
} else {
  # extend with distinct dark HCL hues
  extra <- grDevices::hcl.colors(length(ct_lvls) - length(okabe_ito), palette = "Dark 3")
  ct_cols <- c(okabe_ito, extra)
}
names(ct_cols) <- ct_lvls

# Batch colors (greys so cell_type stands out)
b_lvls <- levels(ann_col$Batch)
b_cols <- setNames(colorRampPalette(c("#4B0082","#FF00FF"))(length(b_lvls)), b_lvls)

ann_colors <- list(
  cell_type = ct_cols,
  Batch     = b_cols
)



# Heatmap palette for distances
pal <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)

# Save the heatmap
dir.create("plots", showWarnings = FALSE, recursive = TRUE)
pheatmap(
  dist_mat,
  color = pal,
  clustering_distance_rows = sample_dists,
  clustering_distance_cols = sample_dists,
  annotation_col = ann_col,
  annotation_colors = ann_colors,        
  show_rownames = TRUE,
  show_colnames = TRUE,
  main = "Sample-to-sample distances (VST)",
  cellwidth  = 18,
  cellheight = 14,
  fontsize_row = 9,   
  fontsize_col = 9,   
  treeheight_row = 50,
  treeheight_col = 50,
  angle_col = 45,
  filename = file.path("plots", "sample_distance_heatmap.png"),
  width = 13, height = 10
)

```





```{r}
suppressPackageStartupMessages({
  library(DESeq2)
  library(AnnotationDbi)
  library(org.Hs.eg.db)
  library(stringr)
  library(readr)
  library(dplyr)
  library(tidyr)
  library(tibble)
})


# Build corrected drug panels (CSV + GMTs)
suppressPackageStartupMessages({ library(readr); library(dplyr); library(stringr) })

panels_dir <- "drug_gene_panels"
dir.create(panels_dir, showWarnings = FALSE, recursive = TRUE)

write_gmt <- function(list_of_sets, path){
  dir.create(dirname(path), showWarnings = FALSE, recursive = TRUE)
  con <- file(path, "w"); on.exit(close(con))
  for (nm in names(list_of_sets)) {
    genes <- unique(na.omit(list_of_sets[[nm]]))
    if (!length(genes)) next
    writeLines(paste(c(nm, "NA", genes), collapse = "\t"), con)
  }
  message("Wrote GMT: ", path)
}

# Shared FGFR blocks
FGFR_adaptors  <- c("FRS2","GRB2","SOS1","GAB1","SHC1","PLCG1")
FGFR_lig_par   <- c("FGF1","FGF2","FGF3","FGF4","FGF5","FGF6","FGF7","FGF8","FGF9","FGF10","FGF18","FGF20")
FGFR_lig_end   <- c("FGF19","FGF21","FGF23","KLB","KL")
FGFR_MAPK      <- c("HRAS","KRAS","NRAS","RAF1","BRAF","MAP2K1","MAP2K2","MAPK1","MAPK3","DUSP6","SPRY2","SPRY4","ETV4","ETV5")
FGFR_PI3K      <- c("PIK3CA","PIK3CB","PIK3CD","PIK3R1","PTEN","AKT1","AKT2","AKT3","MTOR","RPS6KB1","RPS6KB2")
FGFR_STAT_PLC  <- c("STAT1","STAT3","STAT5A","STAT5B","PLCG1")
FGFR_feedback  <- c("SPRY2","SPRY4","DUSP6","IL17RD")
FGFR_fusions   <- c("TACC3","BICC1","BAG4","ZMYM2","NDC80","AFF3","CCDC6","KIAA1217","KIAA1598")
RTK_crosstalk  <- c("ERBB2","ERBB3","MET","PDGFRA","PDGFRB")

build_fgfr_drug <- function(drug, receptors){
  out_csv <- file.path(panels_dir, sprintf("%s_gene_panel.csv", drug))
  gmt_dir <- file.path(panels_dir, sprintf("%s_gmts", drug))
  dir.create(gmt_dir, showWarnings = FALSE, recursive = TRUE)

  panel <- unique(c(
    receptors, FGFR_adaptors, FGFR_lig_par, FGFR_lig_end,
    FGFR_MAPK, FGFR_PI3K, FGFR_STAT_PLC, FGFR_feedback,
    FGFR_fusions, RTK_crosstalk
  ))
  tibble(symbol = sort(panel)) %>% write_csv(out_csv)
  message("Wrote panel CSV: ", out_csv)

  gmt_core <- list(
    FGFR_RECEPTORS            = receptors,
    FGFR_ADAPTORS             = FGFR_adaptors,
    FGFR_LIGANDS_PARACRINE    = FGFR_lig_par,
    FGFR_LIGANDS_ENDOCRINE    = FGFR_lig_end,
    FGFR_MAPK_AXIS            = FGFR_MAPK,
    FGFR_PI3K_AKT_MTOR_AXIS   = FGFR_PI3K,
    FGFR_STAT_PLC_AXIS        = FGFR_STAT_PLC,
    FGFR_NEGATIVE_FEEDBACK    = FGFR_feedback
  )
  write_gmt(gmt_core, file.path(gmt_dir, "FGFR_core_and_pathway.symbols.gmt"))
  write_gmt(list(FGFR_ONCOGENIC_FUSION_PARTNERS = FGFR_fusions),
            file.path(gmt_dir, "FGFR_fusions.symbols.gmt"))
  write_gmt(list(RTK_CROSSTALK_MINIMAL = RTK_crosstalk),
            file.path(gmt_dir, "FGFR_rtk_crosstalk.symbols.gmt"))
}

# Fexagratinib (FGFR1/2/3; FGFR4 excluded)
build_fgfr_drug("Fexagratinib", receptors = c("FGFR1","FGFR2","FGFR3"))

# Erdafitinib (FGFR1/2/3/4 included)
build_fgfr_drug("Erdafitinib",  receptors = c("FGFR1","FGFR2","FGFR3","FGFR4"))

# Carfilzomib (proteasome/UPS/UPR/bounce-back)
build_carfilzomib <- function(){
  drug <- "Carfilzomib"
  out_csv <- file.path(panels_dir, sprintf("%s_gene_panel.csv", drug))
  gmt_dir <- file.path(panels_dir, sprintf("%s_gmts", drug))
  dir.create(gmt_dir, showWarnings = FALSE, recursive = TRUE)

  PROT_20S_ALPHA <- paste0("PSMA", 1:7)
  PROT_20S_BETA  <- c("PSMB1","PSMB2","PSMB3","PSMB4","PSMB5","PSMB6","PSMB7","PSMB8","PSMB9","PSMB10")
  PROT_19S_BASE  <- c("PSMC1","PSMC2","PSMC3","PSMC4","PSMC5","PSMC6")
  PROT_19S_LID   <- c("PSMD1","PSMD2","PSMD3","PSMD4","PSMD5","PSMD6","PSMD7","PSMD8","PSMD9","PSMD10","PSMD11","PSMD12","PSMD13","PSMD14")
  PROT_ASSEMBLY  <- c("POMP","PSMG1","PSMG2","PSMG3","PSMG4")
  DUBs_CORE      <- c("PSMD14","USP14","UCHL5")
  UBIQUITIN_CORE <- c("UBB","UBA52","RPS27A","UBC","UBA1","UBE2D1","UBE2D2","UBE2D3","UBE2D4","UBE2N","UBE2L3")
  E3_LIGASE_AX   <- c("SKP1","CUL1","CUL3","CUL4A","CUL4B","RBX1","BTRC","FBXW7")
  UPR_ER_STRESS  <- c("ATF4","ATF6","XBP1","HSPA5","EIF2AK3","DDIT3")
  BOUNCE_BACK    <- c("NFE2L1","DDI2","NGLY1")
  APOPTOSIS_EXEC <- c("CASP3","CASP7","CASP8","BAX","BAK1","BCL2","BCL2L1","MCL1","BID","BCL2L11")

  panel <- unique(c(
    PROT_20S_ALPHA, PROT_20S_BETA, PROT_19S_BASE, PROT_19S_LID,
    PROT_ASSEMBLY, DUBs_CORE, UBIQUITIN_CORE, E3_LIGASE_AX,
    UPR_ER_STRESS, BOUNCE_BACK, APOPTOSIS_EXEC
  ))
  tibble(symbol = sort(panel)) %>% write_csv(out_csv)
  message("Wrote panel CSV: ", out_csv)

  write_gmt(list(
    PROTEASOME_20S_ALPHA = PROT_20S_ALPHA,
    PROTEASOME_20S_BETA  = PROT_20S_BETA,
    PROTEASOME_19S_BASE  = PROT_19S_BASE,
    PROTEASOME_19S_LID   = PROT_19S_LID,
    PROTEASOME_ASSEMBLY  = PROT_ASSEMBLY
  ), file.path(gmt_dir, "proteasome_core.symbols.gmt"))

  write_gmt(list(
    UBIQUITIN_CONJUGATION_CORE = UBIQUITIN_CORE,
    E3_LIGASE_AXIS             = E3_LIGASE_AX,
    DEUBIQUITINATION_CORE      = DUBs_CORE
  ), file.path(gmt_dir, "ubiquitin_ups.symbols.gmt"))

  write_gmt(list(
    UPR_ER_STRESS = UPR_ER_STRESS,
    PROTEASOME_BOUNCE_BACK_NRF1_AXIS = BOUNCE_BACK
  ), file.path(gmt_dir, "stress_response.symbols.gmt"))

  write_gmt(list(APOPTOSIS_EXECUTION_MODULE = APOPTOSIS_EXEC),
            file.path(gmt_dir, "apoptosis.symbols.gmt"))
}
build_carfilzomib()

# Docetaxel (taxane; MT/spindle/efflux)
build_docetaxel <- function(){
  drug <- "Docetaxel"
  out_csv <- file.path(panels_dir, sprintf("%s_gene_panel.csv", drug))
  gmt_dir <- file.path(panels_dir, sprintf("%s_gmts", drug))
  dir.create(gmt_dir, showWarnings = FALSE, recursive = TRUE)

  MICROTUBULE_BETA   <- c("TUBB","TUBB2A","TUBB2B","TUBB3","TUBB4B","TUBB6")
  MICROTUBULE_ALPHA  <- c("TUBA1A","TUBA1B","TUBA1C","TUBA3C","TUBA4A")
  MT_ASSOCIATED      <- c("MAP4","MAPT","MAP1B","STMN1")
  KINESINS           <- c("KIF11","KIF2C","KIF5B","KIF20A","KIF15")
  SPINDLE_CHECKPOINT <- c("AURKA","AURKB","PLK1","BUB1","BUB1B","MAD2L1","CDC20","CDK1","CCNB1")
  EFFLUX_RESISTANCE  <- c("ABCB1","ABCC10")
  APOPTOSIS_MITOSIS  <- c("BCL2","BCL2L1","MCL1","BAX","BAK1","CASP3","CASP7","CASP8")

  panel <- unique(c(
    MICROTUBULE_BETA, MICROTUBULE_ALPHA, MT_ASSOCIATED,
    KINESINS, SPINDLE_CHECKPOINT, EFFLUX_RESISTANCE, APOPTOSIS_MITOSIS
  ))
  tibble(symbol = sort(panel)) %>% write_csv(out_csv)
  message("Wrote panel CSV: ", out_csv)

  write_gmt(list(
    MICROTUBULE_CORE_BETA    = MICROTUBULE_BETA,
    MICROTUBULE_CORE_ALPHA   = MICROTUBULE_ALPHA,
    MT_ASSOCIATED_REGULATORS = MT_ASSOCIATED
  ), file.path(gmt_dir, "microtubule_core.symbols.gmt"))

  write_gmt(list(
    KINESIN_MOTOR_SET = KINESINS,
    SPINDLE_ASSEMBLY_CHECKPOINT = SPINDLE_CHECKPOINT
  ), file.path(gmt_dir, "mitotic_machinery.symbols.gmt"))

  write_gmt(list(
    TAXANE_EFFLUX_RESISTANCE       = EFFLUX_RESISTANCE,
    APOPTOSIS_AFTER_MITOTIC_STRESS = APOPTOSIS_MITOSIS
  ), file.path(gmt_dir, "taxane_resistance_apoptosis.symbols.gmt"))
}
build_docetaxel()

# Brigimadlin (MDM2–p53 axis)
build_brigimadlin <- function(){
  drug <- "Brigimadlin"
  out_csv <- file.path(panels_dir, sprintf("%s_gene_panel.csv", drug))
  gmt_dir <- file.path(panels_dir, sprintf("%s_gmts", drug))
  dir.create(gmt_dir, showWarnings = FALSE, recursive = TRUE)

  P53_core_axis <- c("TP53","MDM2","MDM4","CDKN2A","TP53BP1","TP53BP2","PPM1D","USP7","RCHY1","RFWD2","EP300","CREBBP")
  P53_apoptosis_targets <- c("BAX","BAK1","PMAIP1","BBC3","FAS","TNFRSF10B","APAF1","TP53I3","BID","BCL2L11")
  P53_cellcycle_targets <- c("CDKN1A","GADD45A","GADD45B","GADD45G","RRM2B","SESN1","SESN2","SESN3","CCNG1","SFN")
  DNA_damage_signaling  <- c("ATM","ATR","CHEK1","CHEK2","TP53BP1","H2AFX","MRE11A","RAD50","NBN","DDB2","XPC")
  P53_feedback_neg_reg  <- c("MDM2","MDM4","PPM1D","RCHY1","RFWD2","USP7","SIRT1","DAXX","PIAS1")
  BCL2_family_mod       <- c("BCL2","BCL2L1","MCL1","BCL2A1","BCL2L2","BCL2L11","BID","BAX","BAK1")
  MDM2_amp_coblock_12q  <- c("MDM2","CDK4","HMGA2","YEATS4","CPM","TSPAN31","LRIG3","SAS10")
  P53_senescence        <- c("CDKN2A","CDKN2B","TP53INP1","ZMAT3","TIGAR")

  panel <- unique(c(
    P53_core_axis, P53_apoptosis_targets, P53_cellcycle_targets,
    DNA_damage_signaling, P53_feedback_neg_reg, BCL2_family_mod,
    MDM2_amp_coblock_12q, P53_senescence
  ))
  tibble(symbol = sort(panel)) %>% write_csv(out_csv)
  message("Wrote panel CSV: ", out_csv)

  write_gmt(list(
    P53_CORE_AXIS                    = P53_core_axis,
    P53_APOPTOSIS_TARGETS            = P53_apoptosis_targets,
    P53_CELL_CYCLE_ARREST_TARGETS    = P53_cellcycle_targets,
    DNA_DAMAGE_SIGNALING             = DNA_damage_signaling,
    P53_FEEDBACK_NEGATIVE_REGULATORS = P53_feedback_neg_reg
  ), file.path(gmt_dir, "p53_core_and_pathway.symbols.gmt"))

  write_gmt(list(BCL2_FAMILY_APOPTOSIS_MODULATORS = BCL2_family_mod),
            file.path(gmt_dir, "bcl2_family.symbols.gmt"))

  write_gmt(list(P53_SENESCENCE_PROGRAM = P53_senescence),
            file.path(gmt_dir, "p53_senescence.symbols.gmt"))

  write_gmt(list(MDM2_AMP_COAMPLIFIED_12Q13_15 = MDM2_amp_coblock_12q),
            file.path(gmt_dir, "mdm2_amp_coblock_12q.symbols.gmt"))
}
build_brigimadlin()

message("All requested panels and GMTs rebuilt under 'drug_gene_panels/'.")


# Batch (optional), Lineage, cell_type, name, and per-drug response columns.
# If needed: dds <- readRDS("Robjects_cell_type/dds.rds")
suppressPackageStartupMessages({
  library(DESeq2); library(dplyr); library(readr); library(tidyr); library(tibble)
  library(AnnotationDbi); library(org.Hs.eg.db); library(stringr)
})

# CONFIG
drugs <- c("Erdafitinib","Fexagratinib","Talazoparib","Obatoclax","Vinblastine","Vincristine")
panels_dir <- "drug_gene_panels"
dir.create("de_by_drug", showWarnings = FALSE, recursive = TRUE)
dir.create("Robjects_by_drug", showWarnings = FALSE, recursive = TRUE)

# Helpers
sanitize      <- function(x) gsub("[^A-Za-z0-9._-]+","_", x)
sanitize_key  <- function(x) gsub("[^a-z0-9]","", tolower(x))

find_response_col <- function(pheno, drug){
  cn <- colnames(pheno); s_cn <- sanitize_key(cn); key <- sanitize_key(drug)
  hits_idx <- which(
    stringr::str_detect(s_cn, paste0("^", key, "resp"))      |
    stringr::str_detect(s_cn, paste0("^", key, "response"))  |
    stringr::str_detect(s_cn, paste0("^", key, "responder")) |
    s_cn == key | stringr::str_detect(s_cn, paste0("^", key, "_?$"))
  )
  if (length(hits_idx)==0) character(0) else cn[hits_idx]
}

standardize_response <- function(x){
  xl <- tolower(trimws(as.character(x)))
  ifelse(
    xl %in% c("responder","r","yes","y","true","1","resp","responders"),
    "Responder",
    ifelse(xl %in% c("non_responder","nonresponder","nr","no","n","false","0","non-responder","non responders","nonresponders"),
           "Non_Responder", NA_character_)
  )
}

map_to_symbol <- function(ens_or_sym){
  sy <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = ens_or_sym,
                              column = "SYMBOL", keytype = "ENSEMBL",
                              multiVals = "first")
  na_frac <- mean(is.na(sy))
  if (is.finite(na_frac) && na_frac > 0.8) { names(ens_or_sym) <- ens_or_sym; return(ens_or_sym) }
  sy
}

is_full_rank_design <- function(coldata, formula){
  mm <- try(model.matrix(formula, data = as.data.frame(coldata)), silent = TRUE)
  if (inherits(mm, "try-error")) return(FALSE)
  all(is.finite(mm)) && nrow(mm) >= ncol(mm) && qr(mm)$rank == ncol(mm)
}

choose_design <- function(dds_sub){
  cd <- as.data.frame(colData(dds_sub))
  if ("Batch" %in% names(cd)) cd$Batch <- droplevels(factor(cd$Batch))
  cd$group <- droplevels(factor(cd$group))
  if ("Batch" %in% names(cd) && nlevels(cd$Batch) > 1 && is_full_rank_design(cd, ~ Batch + group)) return(~ Batch + group)
  if ( is_full_rank_design(cd, ~ group) ) return(~ group)
  NULL
}


read_gmt <- function(path){
  if (!file.exists(path)) return(list())
  con <- file(path, open = "r"); on.exit(close(con))
  out <- list()
  while (length(line <- readLines(con, n = 1, warn = FALSE)) > 0) {
    parts <- strsplit(line, "\t")[[1]]
    if (length(parts) >= 3) out[[parts[1]]] <- parts[-c(1,2)]
  }
  out
}


.first_matching_col <- function(df, candidates){
  nms <- names(df)
  hit <- which(tolower(nms) %in% tolower(candidates))
  if (length(hit)) nms[hit[1]] else nms[1]
}

panel_symbols_for_drug <- function(drug, panels_dir){
  
  panel_syms_csv <- character(0)
  panel_csv <- file.path(panels_dir, paste0(drug, "_gene_panel.csv"))
  if (file.exists(panel_csv)) {
    gp <- readr::read_csv(panel_csv, show_col_types = FALSE)
    cands <- c("symbol","SYMBOL","gene","genes","gene_symbol","hgnc","hgnc_symbol")
    sym_col <- .first_matching_col(gp, cands)
    panel_syms_csv <- unique(na.omit(as.character(gp[[sym_col]])))
  }

  # GMT union (concatenate all *.symbols.gmt gene sets)
  gmt_dir <- file.path(panels_dir, paste0(drug, "_gmts"))
  gmt_files <- if (dir.exists(gmt_dir)) list.files(gmt_dir, pattern = "\\.symbols\\.gmt$", full.names = TRUE) else character(0)
  panel_syms_gmt <- if (length(gmt_files)) unique(unlist(lapply(gmt_files, read_gmt), use.names = FALSE)) else character(0)

  
  unique(toupper(c(panel_syms_csv, panel_syms_gmt)))
}

run_de_and_save <- function(dds_sub, out_dir, sym_map,
                            label_prefix = "", save_rds_basename = NULL,
                            panel_syms = character(0)){
  # Clean factors
  if ("Batch" %in% colnames(colData(dds_sub)))
    colData(dds_sub)$Batch <- droplevels(factor(colData(dds_sub)$Batch))
  colData(dds_sub)$group <- droplevels(factor(colData(dds_sub)$group, levels = c("Non_Responder","Responder")))

  des <- choose_design(dds_sub)
  if (is.null(des)) {
    warning("Design not identifiable for subset '", label_prefix, "' (likely only one class). Skipping.")
    return(list(design = NA_character_, n_sig = NA_integer_, n_panel_all = NA_integer_, n_panel_sig = NA_integer_))
  }
  design(dds_sub) <- des

  de_fit <- DESeq(dds_sub, quiet = TRUE)
  res <- results(de_fit, contrast = c("group","Responder","Non_Responder"), alpha = 0.05)

  res_df <- as.data.frame(res) %>%
    tibble::rownames_to_column("gene_id") %>%
    dplyr::mutate(symbol = unname(sym_map[gene_id])) %>%
    tibble::as_tibble()

  dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

  all_nona <- res_df %>% tidyr::drop_na(padj) %>% dplyr::arrange(padj)
  readr::write_csv(all_nona, file.path(out_dir, paste0(label_prefix, "ALL.csv")))

  sig_nona <- all_nona %>% dplyr::filter(padj < 0.05)
  readr::write_csv(sig_nona, file.path(out_dir, paste0(label_prefix, "SIG_padj_lt_0.05.csv")))

  # Panel-filtered outputs
  panel_all <- panel_sig <- NULL
  if (length(panel_syms) > 0) {
    panel_all <- all_nona %>%
      dplyr::mutate(SYMBOL_UPPER = toupper(symbol), GENE_UPPER = toupper(gene_id)) %>%
      dplyr::filter(SYMBOL_UPPER %in% panel_syms | GENE_UPPER %in% panel_syms) %>%
      dplyr::select(-SYMBOL_UPPER, -GENE_UPPER)
    readr::write_csv(panel_all, file.path(out_dir, paste0(label_prefix, "PANEL_ALL.csv")))

    panel_sig <- sig_nona %>%
      dplyr::mutate(SYMBOL_UPPER = toupper(symbol), GENE_UPPER = toupper(gene_id)) %>%
      dplyr::filter(SYMBOL_UPPER %in% panel_syms | GENE_UPPER %in% panel_syms) %>%
      dplyr::select(-SYMBOL_UPPER, -GENE_UPPER)
    readr::write_csv(panel_sig, file.path(out_dir, paste0(label_prefix, "PANEL_SIG_padj_lt_0.05.csv")))
  }

  if (!is.null(save_rds_basename)) {
    saveRDS(de_fit, file = file.path("Robjects_by_drug", paste0(save_rds_basename, ".rds")))
  }

  list(
    design = deparse(stats::formula(des)),
    n_sig = nrow(sig_nona),
    n_panel_all = if (!is.null(panel_all)) nrow(panel_all) else NA_integer_,
    n_panel_sig = if (!is.null(panel_sig)) nrow(panel_sig) else NA_integer_
  )
}

# symbol map 
ens_ids <- rownames(dds)
sym_map <- map_to_symbol(ens_ids)

# Loop
pheno <- as.data.frame(colData(dds))
stopifnot(all(c("cell_type","Lineage") %in% colnames(pheno)))

sum_overall        <- list()
sum_ct_within_lin  <- list()
sum_ct_global      <- list()

for (drug in drugs) {
  message("\n=== ", drug, " ===")
  resp_candidates <- find_response_col(pheno, drug)
  if (length(resp_candidates) == 0) { warning("No response column found for ", drug, ". Skipping."); next }
  resp_col <- resp_candidates[1]
  resp_std <- standardize_response(pheno[[resp_col]])

  # load panel symbols for this drug
  panel_syms <- panel_symbols_for_drug(drug, panels_dir)

  # OVERALL
  keep_overall <- !is.na(resp_std) & resp_std %in% c("Responder","Non_Responder")
  if (sum(keep_overall) >= 2 && all(c("Responder","Non_Responder") %in% unique(resp_std[keep_overall]))) {
    dds_overall <- dds[, keep_overall]
    colData(dds_overall)$group <- factor(resp_std[keep_overall], levels = c("Non_Responder","Responder"))

    out_dir_overall <- file.path("de_by_drug", drug)
    res_overall <- run_de_and_save(
      dds_sub = dds_overall,
      out_dir = out_dir_overall,
      sym_map = sym_map,
      label_prefix = paste0(drug, "_Responder_vs_NonResponder_"),
      save_rds_basename = paste0("dds_", drug, "_Responder_vs_NonResponders_allLineages"),
      panel_syms = panel_syms
    )

    tab_overall <- table(colData(dds_overall)$group)
    sum_overall[[drug]] <- tibble(
      drug = drug, scope = "overall", lineage = NA_character_, responder_cell_type = NA_character_,
      response_column = resp_col, n_samples = ncol(dds_overall),
      n_responder = unname(tab_overall["Responder"]), n_non_responder = unname(tab_overall["Non_Responder"]),
      design = res_overall$design, n_DE_padj_lt_0_05 = res_overall$n_sig,
      n_DE_panel_ALL = res_overall$n_panel_all, n_DE_panel_SIG = res_overall$n_panel_sig
    )
  }

  # WITHIN-LINEAGE
  lin_vec  <- as.character(pheno$Lineage)
  ct_vec   <- as.character(pheno$cell_type)

  for (lin in unique(na.omit(lin_vec))) {
    idx_lin <- which(lin_vec == lin & !is.na(resp_std) & resp_std %in% c("Responder","Non_Responder"))
    if (length(idx_lin) == 0) next

    df_lin <- tibble(idx = idx_lin, cell_type = ct_vec[idx_lin], resp = resp_std[idx_lin])

    ct_status <- df_lin %>%
      group_by(cell_type) %>%
      summarize(n = n(),
                n_status = n_distinct(resp),
                status = ifelse(n_status == 1, first(resp), NA_character_),
                .groups = "drop")

    resp_cts <- ct_status %>% filter(status == "Responder") %>% pull(cell_type)
    nonr_cts <- ct_status %>% filter(status == "Non_Responder") %>% pull(cell_type)
    if (length(resp_cts) == 0 || length(nonr_cts) == 0) next

    for (ctR in resp_cts) {
      idx <- which(lin_vec == lin & ct_vec %in% c(ctR, nonr_cts) &
                     !is.na(resp_std) & resp_std %in% c("Responder","Non_Responder"))
      if (length(idx) < 2) next

      dds_ct <- dds[, idx]
      grp <- ifelse(ct_vec[idx] == ctR, "Responder", "Non_Responder")
      colData(dds_ct)$group <- factor(grp, levels = c("Non_Responder","Responder"))

      out_dir_ct <- file.path("de_by_drug", drug, "by_lineage_celltype", sanitize(lin), sanitize(ctR))
      label_prefix <- paste0(drug, "_", sanitize(lin), "_", sanitize(ctR), "_Responder_vs_NonResponders_")

      res_ct <- run_de_and_save(
        dds_sub = dds_ct,
        out_dir = out_dir_ct,
        sym_map = sym_map,
        label_prefix = label_prefix,
        save_rds_basename = paste0("dds_", drug, "_", sanitize(lin), "_", sanitize(ctR), "_vs_NonResponders_withinLineage"),
        panel_syms = panel_syms
      )

      tab_ct <- table(colData(dds_ct)$group)
      sum_ct_within_lin[[paste(drug, lin, ctR, sep="|")]] <- tibble(
        drug = drug, scope = "by_lineage_celltype",
        lineage = lin, responder_cell_type = ctR,
        response_column = resp_col,
        n_samples = ncol(dds_ct),
        n_responder_samples = unname(tab_ct["Responder"]),
        n_non_responder_samples = unname(tab_ct["Non_Responder"]),
        design = res_ct$design,
        n_DE_padj_lt_0_05 = res_ct$n_sig,
        n_DE_panel_ALL = res_ct$n_panel_all,
        n_DE_panel_SIG = res_ct$n_panel_sig
      )
    }
  }

  # GLOBAL per-cell-type (e.g., MFS1) vs ALL Non-Responders (ignoring lineage)
  valid_idx <- which(!is.na(resp_std) & resp_std %in% c("Responder","Non_Responder"))
  if (length(valid_idx) >= 2) {
    df_global <- tibble(cell_type = ct_vec[valid_idx], resp = resp_std[valid_idx])
    ct_status_global <- df_global %>%
      group_by(cell_type) %>%
      summarize(n = n(), n_status = n_distinct(resp),
                status = ifelse(n_status == 1, first(resp), NA_character_), .groups = "drop")

    resp_cts_global <- ct_status_global %>% filter(status == "Responder") %>% pull(cell_type)
    nonr_cts_global <- ct_status_global %>% filter(status == "Non_Responder") %>% pull(cell_type)

    if (length(resp_cts_global) > 0 && length(nonr_cts_global) > 0) {
      for (ctR in resp_cts_global) {
        idx <- which(ct_vec %in% c(ctR, nonr_cts_global) &
                       !is.na(resp_std) & resp_std %in% c("Responder","Non_Responder"))
        if (length(idx) < 3) next  # need enough samples

        dds_ct_glob <- dds[, idx]
        grp <- ifelse(ct_vec[idx] == ctR, "Responder", "Non_Responder")
        colData(dds_ct_glob)$group <- factor(grp, levels = c("Non_Responder","Responder"))

        out_dir_glob <- file.path("de_by_drug", drug, "by_celltype_global", sanitize(ctR))
        label_prefix <- paste0(drug, "_GLOBAL_", sanitize(ctR), "_Responder_vs_ALL_NonResponders_")

        res_glob <- run_de_and_save(
          dds_sub = dds_ct_glob,
          out_dir = out_dir_glob,
          sym_map = sym_map,
          label_prefix = label_prefix,
          save_rds_basename = paste0("dds_", drug, "_GLOBAL_", sanitize(ctR), "_vs_ALL_NonResponders"),
          panel_syms = panel_syms   # PANEL FILTERING INCLUDED HERE
        )

        tab_g <- table(colData(dds_ct_glob)$group)
        sum_ct_global[[paste(drug, ctR, sep="|")]] <- tibble(
          drug = drug, scope = "by_celltype_global",
          lineage = NA_character_, responder_cell_type = ctR,
          response_column = resp_col,
          n_samples = ncol(dds_ct_glob),
          n_responder_samples = unname(tab_g["Responder"]),
          n_non_responder_samples = unname(tab_g["Non_Responder"]),
          design = res_glob$design,
          n_DE_padj_lt_0_05 = res_glob$n_sig,
          n_DE_panel_ALL = res_glob$n_panel_all,
          n_DE_panel_SIG = res_glob$n_panel_sig
        )
      }
    }
  }
}

# Summaries
if (length(sum_overall)) {
  bind_rows(sum_overall) %>%
    arrange(drug, desc(n_DE_padj_lt_0_05)) %>%
    write_csv(file.path("de_by_drug", "DE_summary_overall_by_drug.csv"))
}
if (length(sum_ct_within_lin)) {
  bind_rows(sum_ct_within_lin) %>%
    arrange(drug, lineage, responder_cell_type, desc(n_DE_padj_lt_0_05)) %>%
    write_csv(file.path("de_by_drug", "DE_summary_by_drug_lineage_celltype.csv"))
}
if (length(sum_ct_global)) {
  bind_rows(sum_ct_global) %>%
    arrange(drug, responder_cell_type, desc(n_DE_padj_lt_0_05)) %>%
    write_csv(file.path("de_by_drug", "DE_summary_by_drug_celltype_GLOBAL.csv"))
}

message("Done. PANEL_* files are now saved for overall, within-lineage, and GLOBAL per-cell-type analyses.")



```



#clusterProfiler gseGO enrichment (GSEA-style) with dotplots, emapplots, cnetplots
```{r}

# lusterProfiler GSEA: gseGO + MSigDB Reactome & Hallmark (dotplot / emapplot / cnetplot / gseaplot2)

suppressPackageStartupMessages({
  library(dplyr); library(readr); library(tidyr); library(tibble)
  library(stringr); library(ggplot2)
  library(clusterProfiler); library(enrichplot)
  library(msigdbr)
  library(AnnotationDbi); library(org.Hs.eg.db)
})

# Config 
de_root   <- "de_by_drug"               
out_root  <- "enrichment_by_drug_cp"    # output root for clusterProfiler GSEA
dir.create(out_root, showWarnings = FALSE, recursive = TRUE)

go_ontologies   <- c("BP","MF")     

# GSEA settings
minGS_go        <- 10                   
minGS_sets      <- 10                   
maxGSSize       <- 500
pAdjustMethod   <- "BH"
pvalueCutoff_all <- 1                   
eps_break_ties  <- TRUE                 
set.seed(42)

# Panel-restricted settings
panel_minGS_go    <- 2
panel_minGS_sets  <- 2
pvalueCutoff_pan  <- 1                  

# Filenames
max_slug_chars <- 80
safe_slug <- function(x, max_n = 80) {
  s <- gsub("[^A-Za-z0-9._-]+", "_", x)
  s <- gsub("^_+|_+$", "", s)
  if (nchar(s) <= max_n) return(s)
  if (requireNamespace("digest", quietly = TRUE)) {
    paste0(substr(s, 1, max_n - 9), "_", substr(digest::digest(s), 1, 8))
  } else substr(s, 1, max_n)
}

# Helpers
# Build ENTREZID-named ranking vector from *_ALL.csv
make_geneList <- function(path_csv) {
  df <- readr::read_csv(path_csv, show_col_types = FALSE)

  # find symbol column or map from Ensembl
  sym_col <- if ("symbol" %in% names(df)) "symbol" else if ("SYMBOL" %in% names(df)) "SYMBOL" else NULL
  if (is.null(sym_col)) {
    if (!"gene_id" %in% names(df)) stop("No 'symbol' or 'gene_id' in: ", path_csv)
    sy <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = df$gene_id,
                                column = "SYMBOL", keytype = "ENSEMBL", multiVals = "first")
    df$symbol <- unname(sy); sym_col <- "symbol"
  }

  # Ranking score preference
  if ("stat" %in% names(df) && all(!is.na(df$stat))) {
    score <- df$stat
  } else if (all(c("log2FoldChange","pvalue") %in% names(df))) {
    pv <- pmax(df$pvalue, .Machine$double.xmin)
    score <- sign(df$log2FoldChange) * -log10(pv)
  } else if ("log2FoldChange" %in% names(df)) {
    score <- df$log2FoldChange
  } else stop("Cannot build ranking for: ", path_csv)

  ranks_sym <- tibble(symbol = df[[sym_col]], score = score) %>%
    filter(!is.na(symbol), !is.na(score)) %>%
    group_by(symbol) %>% summarise(score = score[which.max(abs(score))], .groups = "drop")

  ent <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = ranks_sym$symbol,
                               column = "ENTREZID", keytype = "SYMBOL", multiVals = "first")
  geneList <- ranks_sym$score; names(geneList) <- unname(ent)
  gl <- tibble(ENTREZID = names(geneList), score = geneList) %>%
    filter(!is.na(ENTREZID)) %>%
    group_by(ENTREZID) %>% summarise(score = score[which.max(abs(score))], .groups = "drop") %>%
    arrange(desc(score)) %>% { setNames(.$score, .$ENTREZID) }

  if (eps_break_ties) gl <- gl + rnorm(length(gl), sd = 1e-8)
  sort(gl, decreasing = TRUE)
}

# msigdbr helper
make_termsets <- function(collection, subcollection = NULL, tag) {
  # Try new API first -> fallback to old if needed
  df <- try(msigdbr::msigdbr(species = "Homo sapiens",
                             collection = collection, subcollection = subcollection),
            silent = TRUE)
  if (inherits(df, "try-error")) {
    df <- try(msigdbr::msigdbr(species = "Homo sapiens",
                               category = collection, subcategory = subcollection),
              silent = TRUE)
  }
  if (inherits(df, "try-error") || is.null(df) || nrow(df) == 0) {
    warning("msigdbr missing/empty for ", tag, " (", collection, " / ", subcollection, ").")
    return(list(
      TERM2GENE = data.frame(term = character(), gene = character()),
      TERM2NAME = data.frame(term = character(), name = character())
    ))
  }

  # robust column selection
  gs_col <- if ("gs_name" %in% names(df)) "gs_name" else {
    cand <- names(df)[grepl("gs.?name", names(df), ignore.case = TRUE)]
    if (length(cand)) cand[1] else NA_character_
  }
  id_col <- if ("entrez_gene" %in% names(df)) "entrez_gene" else {
    cand <- names(df)[grepl("entrez", names(df), ignore.case = TRUE)]
    if (length(cand)) cand[1] else NA_character_
  }
  desc_col <- if ("gs_description" %in% names(df)) "gs_description" else NA_character_

  if (is.na(gs_col) || is.na(id_col)) {
    warning("msigdbr columns not found for ", tag, ". Available: ", paste(names(df), collapse = ", "))
    return(list(
      TERM2GENE = data.frame(term = character(), gene = character()),
      TERM2NAME = data.frame(term = character(), name = character())
    ))
  }

  t2g <- df %>%
    dplyr::select(all_of(gs_col), all_of(id_col)) %>%
    dplyr::distinct() %>%
    dplyr::filter(!is.na(.data[[id_col]])) %>%
    dplyr::rename(term = !!gs_col, gene = !!id_col) %>%
    as.data.frame()

  t2n <- if (!is.na(desc_col) && desc_col %in% names(df)) {
    df %>%
      dplyr::select(all_of(gs_col), all_of(desc_col)) %>%
      dplyr::distinct() %>%
      dplyr::rename(term = !!gs_col, name = !!desc_col) %>%
      as.data.frame()
  } else {
    data.frame(term = unique(df[[gs_col]]), name = unique(df[[gs_col]]), stringsAsFactors = FALSE)
  }

  list(TERM2GENE = t2g, TERM2NAME = t2n)
}

# Robust panel -> ENTREZ mapping
guess_id_type <- function(x) {
  x <- na.omit(trimws(as.character(x)))
  if (!length(x)) return("UNKNOWN")
  if (mean(grepl("^ENSG\\d+", x)) > 0.6) return("ENSEMBL")
  if (mean(grepl("^\\d+$", x))   > 0.6) return("ENTREZ")
  "SYMBOL_OR_ALIAS"
}

map_to_entrez <- function(vec) {
  vec <- unique(na.omit(trimws(as.character(vec))))
  if (!length(vec)) return(character(0))
  idt <- guess_id_type(vec)

  if (idt == "ENTREZ") {
    return(unique(vec))
  } else if (idt == "ENSEMBL") {
    ent <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = vec,
                                 column = "ENTREZID", keytype = "ENSEMBL",
                                 multiVals = "first")
    return(unique(na.omit(unname(ent))))
  } else {
    ent1 <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = vec,
                                  column = "ENTREZID", keytype = "SYMBOL",
                                  multiVals = "first")
    miss <- is.na(ent1)
    if (any(miss)) {
      ent2 <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = vec[miss],
                                    column = "ENTREZID", keytype = "ALIAS",
                                    multiVals = "first")
      ent1[miss] <- ent2
    }
    return(unique(na.omit(unname(ent1))))
  }
}

panel_csv_to_entrez <- function(panel_csv) {
  if (!file.exists(panel_csv)) return(character(0))
  df <- readr::read_csv(panel_csv, show_col_types = FALSE)
  if (!nrow(df)) return(character(0))

  candidate_cols <- c("symbol","SYMBOL","gene","genes","gene_symbol","hgnc","hgnc_symbol",
                      "Gene","GeneSymbol","HGNC","HGNC_symbol","gene_id","ENSEMBL","ensembl",
                      "entrez","ENTREZID")
  use_col <- candidate_cols[candidate_cols %in% names(df)][1]
  if (is.na(use_col) || length(use_col) == 0) use_col <- names(df)[1]

  map_to_entrez(df[[use_col]])
}

# Restrict ENTREZ geneList by *_PANEL_ALL.csv contents
restrict_geneList_by_panel <- function(geneList, panel_csv, out_dir = NULL, label_panel = NULL) {
  entrez_panel <- panel_csv_to_entrez(panel_csv)
  gl <- geneList[names(geneList) %in% entrez_panel]

  if (!is.null(out_dir) && !is.null(label_panel)) {
    dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
    txt <- file.path(out_dir, paste0(label_panel, "_panel_mapping_summary.txt"))
    cat(paste0(
      "Panel mapping summary for ", label_panel, "\n",
      "panel_csv: ", panel_csv, "\n",
      "n_geneList (full)       = ", length(geneList), "\n",
      "n_panel_ENTREZ_mapped   = ", length(entrez_panel), "\n",
      "n_geneList_after_panel  = ", length(gl), "\n"
    ), file = txt)
  }
  sort(gl, decreasing = TRUE)
}

# Robust saver
save_cp_outputs <- function(gse, geneList, out_dir, label, tag,
                            top_dot = 20, top_emap = 30, top_cnet = 10, top_gsea = 3) {
  dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
  dir.create(file.path(out_dir, "plots"), showWarnings = FALSE, recursive = TRUE)

  # Quick exit if no results
  if (is.null(gse) || nrow(as.data.frame(gse)) == 0) {
    readr::write_csv(tibble(), file.path(out_dir, paste0(label, "_GSEA_", tag, "_none.csv")))
    return(invisible(NULL))
  }

  # Safe ggsave wrapper
  safe_ggsave <- function(path, plot, width, height, dpi = 150) {
    tryCatch(
      { ggplot2::ggsave(path, plot = plot, width = width, height = height, dpi = dpi) },
      error = function(e) message("Skipping save for ", basename(path), ": ", e$message)
    )
  }

  # Keep raw (ENTREZ) and readable (SYMBOL) versions
  gse_raw  <- gse
  gse_read <- tryCatch(clusterProfiler::setReadable(gse, OrgDb = org.Hs.eg.db, keyType = "ENTREZID"),
                       error = function(e) gse_raw)

  # Results table
  res_df <- as.data.frame(gse_read) %>% dplyr::arrange(p.adjust, dplyr::desc(NES))
  if (nrow(res_df) == 0) {
    readr::write_csv(tibble(), file.path(out_dir, paste0(label, "_GSEA_", tag, "_none.csv")))
    return(invisible(NULL))
  }
  readr::write_csv(res_df, file.path(out_dir, paste0(label, "_GSEA_", tag, "_results.csv")))

  # Dotplot
  n_dot <- min(top_dot, nrow(res_df))
  if (n_dot >= 1) {
    dp <- tryCatch(
      enrichplot::dotplot(gse_read, showCategory = n_dot) +
        ggtitle(paste0("GSEA (", tag, ") — ", label)),
      error = function(e) NULL
    )
    if (!is.null(dp)) {
      safe_ggsave(file.path(out_dir, "plots", paste0(label, "_GSEA_", tag, "_dotplot.png")),
                  dp, width = 10, height = 8)
    }
  }

  # Enrichment map
  if (requireNamespace("igraph", quietly = TRUE) &&
      requireNamespace("ggraph", quietly = TRUE) &&
      nrow(res_df) >= 2) {
    gse_sim <- tryCatch(enrichplot::pairwise_termsim(gse_read), error = function(e) NULL)
    if (!is.null(gse_sim)) {
      ep <- tryCatch(
        enrichplot::emapplot(gse_sim, showCategory = min(top_emap, nrow(res_df)), layout = "kk") +
          ggtitle(paste0("emapplot GSEA (", tag, ") — ", label)),
        error = function(e) NULL
      )
      if (!is.null(ep)) {
        safe_ggsave(file.path(out_dir, "plots", paste0(label, "_GSEA_", tag, "_emap.png")),
                    ep, width = 10, height = 15)
      }
    }
  }

  # cnetplot
  fc_sym <- tryCatch({
    sy <- AnnotationDbi::mapIds(org.Hs.eg.db, keys = names(geneList),
                                column = "SYMBOL", keytype = "ENTREZID", multiVals = "first")
    stats::setNames(unname(geneList), sy) |> na.omit()
  }, error = function(e) numeric(0))

  # Try SYMBOL first -> fallback to raw (ENTREZ) if needed
  cn <- tryCatch(
    enrichplot::cnetplot(gse_read, showCategory = min(top_cnet, nrow(res_df)),
                         foldChange = fc_sym, circular = FALSE),
    error = function(e) NULL
  )
  if (is.null(cn)) {
    cn <- tryCatch(
      enrichplot::cnetplot(gse_raw, showCategory = min(top_cnet, nrow(as.data.frame(gse_raw))),
                           foldChange = geneList, circular = FALSE),
      error = function(e) NULL
    )
  }
  if (!is.null(cn)) {
    safe_ggsave(file.path(out_dir, "plots", paste0(label, "_GSEA_", tag, "_cnet.png")),
                cn, width = 12, height = 12)
  }

  # gseaplot2 for top up/down by NES
  res_tbl  <- as.data.frame(gse_read)
  top_up   <- res_tbl %>% dplyr::filter(NES > 0) %>% dplyr::arrange(dplyr::desc(NES)) %>% dplyr::pull(ID) %>% head(3)
  top_down <- res_tbl %>% dplyr::filter(NES < 0) %>% dplyr::arrange(NES)               %>% dplyr::pull(ID) %>% head(3)

  plot_one <- function(id, dir_tag) {
    gp <- tryCatch(enrichplot::gseaplot2(gse_read, geneSetID = id, title = paste0(id, " (", dir_tag, ")")),
                   error = function(e) NULL)
    if (!is.null(gp)) {
      fn <- paste0(label, "_GSEA_", tag, "_", safe_slug(id, max_slug_chars), "_", dir_tag, ".png")
      safe_ggsave(file.path(out_dir, "plots", fn), gp, width = 10, height = 10)
    }
  }
  if (length(top_up))   for (id in top_up)   plot_one(id, "UP")
  if (length(top_down)) for (id in top_down) plot_one(id, "DOWN")
}

# term sets Reactome & Hallmark
reactome_sets <- make_termsets(collection = "C2", subcollection = "CP:REACTOME", tag = "REACTOME")
hallmark_sets <- make_termsets(collection = "H",  subcollection = NULL,          tag = "HALLMARK")

all_de_files <- list.files(de_root, pattern = "_ALL\\.csv$", recursive = TRUE, full.names = TRUE)
if (length(all_de_files) == 0) stop("No DE files found under '", de_root, "' (expected '*_ALL.csv').")

for (csv_path in all_de_files) {
  rel     <- stringr::str_replace(csv_path, paste0("^", de_root), "")
  rel_dir <- dirname(rel)
  out_dir <- file.path(out_root, rel_dir)
  dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

  label <- tools::file_path_sans_ext(basename(csv_path))

  
  geneList <- tryCatch(make_geneList(csv_path),
                       error = function(e) { message("Skipping GSEA for ", csv_path, ": ", e$message); NULL })
  if (is.null(geneList) || length(geneList) < min(minGS_go, minGS_sets)) {
    readr::write_csv(tibble(), file.path(out_dir, paste0(label, "_GSEA_none.csv")))
    next
  }

  # gseGO (relaxed pvalueCutoff)
  for (ont in go_ontologies) {
    gse_go <- tryCatch(
      clusterProfiler::gseGO(
        geneList      = geneList,
        OrgDb         = org.Hs.eg.db,
        keyType       = "ENTREZID",
        ont           = ont,
        minGSSize     = minGS_go,
        maxGSSize     = maxGSSize,
        pAdjustMethod = pAdjustMethod,
        pvalueCutoff  = pvalueCutoff_all,   
        verbose       = FALSE
      ),
      error = function(e) NULL
    )
    save_cp_outputs(gse_go, geneList, out_dir, label, paste0("GO_", ont))
  }

  # Reactome -> MSigDB
  if (nrow(reactome_sets$TERM2GENE) > 0) {
    gse_re <- tryCatch(
      clusterProfiler::GSEA(
        geneList      = geneList,
        TERM2GENE     = reactome_sets$TERM2GENE,
        TERM2NAME     = reactome_sets$TERM2NAME,
        minGSSize     = minGS_sets,
        maxGSSize     = maxGSSize,
        pAdjustMethod = pAdjustMethod,
        pvalueCutoff  = pvalueCutoff_all, 
        verbose       = FALSE,
        seed          = TRUE
      ),
      error = function(e) NULL
    )
    save_cp_outputs(gse_re, geneList, out_dir, label, "REACTOME")
  } else {
    readr::write_csv(tibble(), file.path(out_dir, paste0(label, "_GSEA_REACTOME_none.csv")))
  }

  # Hallmark -> MSigDB
  if (nrow(hallmark_sets$TERM2GENE) > 0) {
    gse_h <- tryCatch(
      clusterProfiler::GSEA(
        geneList      = geneList,
        TERM2GENE     = hallmark_sets$TERM2GENE,
        TERM2NAME     = hallmark_sets$TERM2NAME,
        minGSSize     = minGS_sets,
        maxGSSize     = maxGSSize,
        pAdjustMethod = pAdjustMethod,
        pvalueCutoff  = pvalueCutoff_all,   
        verbose       = FALSE,
        seed          = TRUE
      ),
      error = function(e) NULL
    )
    save_cp_outputs(gse_h, geneList, out_dir, label, "HALLMARK")
  } else {
    readr::write_csv(tibble(), file.path(out_dir, paste0(label, "_GSEA_HALLMARK_none.csv")))
  }

  # Panel-restricted variants
  panel_all_csv <- sub("_ALL\\.csv$", "_PANEL_ALL.csv", csv_path)
  if (file.exists(panel_all_csv)) {
    label_panel    <- paste0(label, "_PANEL")
    geneList_panel <- restrict_geneList_by_panel(geneList, panel_all_csv,
                                                 out_dir = out_dir, label_panel = label_panel)

    panel_minGS_go_eff   <- max(2, panel_minGS_go)
    panel_minGS_sets_eff <- max(2, panel_minGS_sets)

    if (length(geneList_panel) >= min(panel_minGS_go_eff, panel_minGS_sets_eff)) {

      # gseGO (panel)
      for (ont in go_ontologies) {
        gse_go_p <- tryCatch(
          clusterProfiler::gseGO(
            geneList      = geneList_panel,
            OrgDb         = org.Hs.eg.db,
            keyType       = "ENTREZID",
            ont           = ont,
            minGSSize     = panel_minGS_go_eff,
            maxGSSize     = maxGSSize,
            pAdjustMethod = pAdjustMethod,
            pvalueCutoff  = pvalueCutoff_pan, 
            verbose       = FALSE
          ),
          error = function(e) NULL
        )
        save_cp_outputs(gse_go_p, geneList_panel, out_dir, label_panel, paste0("GO_", ont))
      }

      # Reactome (panel)
      if (nrow(reactome_sets$TERM2GENE) > 0) {
        gse_re_p <- tryCatch(
          clusterProfiler::GSEA(
            geneList      = geneList_panel,
            TERM2GENE     = reactome_sets$TERM2GENE,
            TERM2NAME     = reactome_sets$TERM2NAME,
            minGSSize     = panel_minGS_sets_eff,
            maxGSSize     = maxGSSize,
            pAdjustMethod = pAdjustMethod,
            pvalueCutoff  = pvalueCutoff_pan, 
            verbose       = FALSE,
            seed          = TRUE
          ),
          error = function(e) NULL
        )
        save_cp_outputs(gse_re_p, geneList_panel, out_dir, label_panel, "REACTOME")
      }

      # Hallmark (panel)
      if (nrow(hallmark_sets$TERM2GENE) > 0) {
        gse_h_p <- tryCatch(
          clusterProfiler::GSEA(
            geneList      = geneList_panel,
            TERM2GENE     = hallmark_sets$TERM2GENE,
            TERM2NAME     = hallmark_sets$TERM2NAME,
            minGSSize     = panel_minGS_sets_eff,
            maxGSSize     = maxGSSize,
            pAdjustMethod = pAdjustMethod,
            pvalueCutoff  = pvalueCutoff_pan, 
            verbose       = FALSE,
            seed          = TRUE
          ),
          error = function(e) NULL
        )
        save_cp_outputs(gse_h_p, geneList_panel, out_dir, label_panel, "HALLMARK")
      }

    } else {
      readr::write_csv(tibble(), file.path(out_dir, paste0(label_panel, "_GSEA_panel_none.csv")))
    }
  }
}

message("Done. clusterProfiler GSEA (GO/Reactome/Hallmark; full + PANEL) saved under '", out_root, "'.")


```

